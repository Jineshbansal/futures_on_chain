import {
  require_eventemitter3
} from "./chunk-3XBZTA5C.js";
import {
  require_buffer
} from "./chunk-27RUZNJR.js";
import {
  require_jsx_runtime
} from "./chunk-K4QCH4XS.js";
import {
  require_react
} from "./chunk-QV6VW2LK.js";
import {
  HexString,
  aptosClient,
  aptos_types_exports,
  bcs_exports,
  require_lib,
  require_nacl_fast
} from "./chunk-BMUDJNCS.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number3(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number3;
    function bool2(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool2;
    function bytes3(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes3;
    function hash3(hash4) {
      if (typeof hash4 !== "function" || typeof hash4.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number3(hash4.outputLen);
      number3(hash4.blockLen);
    }
    exports.hash = hash3;
    function exists3(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists3;
    function output3(out, instance) {
      bytes3(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output3;
    var assert2 = {
      number: number3,
      bool: bool2,
      bytes: bytes3,
      hash: hash3,
      exists: exists3,
      output: output3
    };
    exports.default = assert2;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js
var require_cryptoBrowser = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = {
      node: void 0,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_cryptoBrowser();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView3;
    var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr2;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes4 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex3(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes4[uint8a[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex3;
    function hexToBytes3(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes3;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes4(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes4;
    function toBytes3(data) {
      if (typeof data === "string")
        data = utf8ToBytes4(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes3;
    function concatBytes3(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes3;
    var Hash3 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash3;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor3(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes3(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor3;
    function wrapConstructorWithOpts2(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts2;
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    }
    exports.randomBytes = randomBytes2;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC3 = class extends utils_js_1.Hash {
      constructor(hash3, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash3);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash3.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash3.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac3 = (hash3, key, message) => new HMAC3(hash3, key).update(message).digest();
    exports.hmac = hmac3;
    exports.hmac.create = (hash3, key) => new HMAC3(hash3, key);
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash3, _password, _salt, _opts) {
      _assert_js_1.default.hash(hash3);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      _assert_js_1.default.number(c);
      _assert_js_1.default.number(dkLen);
      _assert_js_1.default.number(asyncTick);
      if (c < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash3, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash3, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view2 = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view2.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash3, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view2 = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view2.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i2 = 0; i2 < Ti.length; i2++)
            Ti[i2] ^= u[i2];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint643(view2, byteOffset, value, isLE3) {
      if (typeof view2.setBigUint64 === "function")
        return view2.setBigUint64(byteOffset, value, isLE3);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE3 ? 4 : 0;
      const l = isLE3 ? 0 : 4;
      view2.setUint32(byteOffset + h, wh, isLE3);
      view2.setUint32(byteOffset + l, wl, isLE3);
    }
    var SHA23 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view: view2, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view2, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view: view2, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view2, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint643(view2, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view2, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE3);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA23;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi2 = (a, b, c) => a & b ^ ~a & c;
    var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K2 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV2 = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W2 = new Uint32Array(64);
    var SHA2562 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV2[0] | 0;
        this.B = IV2[1] | 0;
        this.C = IV2[2] | 0;
        this.D = IV2[3] | 0;
        this.E = IV2[4] | 0;
        this.F = IV2[5] | 0;
        this.G = IV2[6] | 0;
        this.H = IV2[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view2, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W2[i] = view2.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W2[i - 15];
          const W2 = SHA256_W2[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj2(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W2.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA2242 = class extends SHA2562 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2242());
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK642 = BigInt(2 ** 32 - 1);
    var _32n2 = BigInt(32);
    function fromBig2(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
      return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
    }
    exports.fromBig = fromBig2;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig2(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
    exports.toBig = toBig2;
    var shrSH2 = (h, l, s) => h >>> s;
    var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H2 = (h, l) => l;
    var rotr32L2 = (h, l) => h;
    var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add2;
    var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u642 = {
      fromBig: fromBig2,
      split: split2,
      toBig: exports.toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports.default = u642;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh2, SHA512_Kl2] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    var SHA512_W_H2 = new Uint32Array(80);
    var SHA512_W_L2 = new Uint32Array(80);
    var SHA5122 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view2, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H2[i] = view2.getUint32(offset);
          SHA512_W_L2[i] = view2.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H2[i - 15] | 0;
          const W15l = SHA512_W_L2[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i - 2] | 0;
          const W2l = SHA512_W_L2[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
          SHA512_W_H2[i] = SUMh | 0;
          SHA512_W_L2[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H2.fill(0);
        SHA512_W_L2.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA5122;
    var SHA512_224 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_2562 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA3842 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5122());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2562());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3842());
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      _assert_1.default.number(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== "string")
        throw new Error("Worlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error(`Wordlist: non-string element: ${i}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "　" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed2(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToSeedSync2(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync2;
  }
});

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/cryptoBrowser.js
var crypto = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (h, l) => l;
var rotr32L = (h, l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    assert_default.number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view2, byteOffset, value, isLE3) {
  if (typeof view2.setBigUint64 === "function")
    return view2.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view2.setUint32(byteOffset + h, wh, isLE3);
  view2.setUint32(byteOffset + l, wl, isLE3);
}
var SHA2 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view: view2, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view2, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer, view: view2, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view2, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view2, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view2, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view2, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view2.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor2(() => new SHA256());
var sha224 = wrapConstructor2(() => new SHA224());

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes3 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes3[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex2(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0; Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n3);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n5;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN2(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n5)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n5;
  for (let o = q - _1n5; o % _2n4 === _0n5; o /= _2n4)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n5) / _2n4);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n5; i--) {
      let tv52 = i - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes3(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash3, expand, DST: _DST } = options;
  isBytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash2(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n5 !== _0n6)
    y = modP(-y);
  const p = new Point(x, y, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view2, byteOffset, value, isLE3) {
  if (typeof view2.setBigUint64 === "function")
    return view2.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view2.setUint32(byteOffset + h, wh, isLE3);
  view2.setUint32(byteOffset + l, wl, isLE3);
}
var SHA22 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view: view2, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view2, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view: view2, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view2, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint642(view2, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view2, 0);
    const oview = createView(out);
    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE3));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@aptos-labs/ts-sdk/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA22 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view2, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view2.getUint32(offset);
      SHA512_W_L[i] = view2.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs
var bip39 = __toESM(require_bip39(), 1);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var AptosApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "AptosApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.data = response.data;
    this.request = request2;
  }
};
var VERSION = "2.0.0";
var MimeType = ((MimeType2) => {
  MimeType2["JSON"] = "application/json";
  MimeType2["BCS"] = "application/x-bcs";
  MimeType2["BCS_SIGNED_TRANSACTION"] = "application/x.aptos.signed_transaction+bcs";
  return MimeType2;
})(MimeType || {});
var TypeTagVariants = ((TypeTagVariants2) => {
  TypeTagVariants2[TypeTagVariants2["Bool"] = 0] = "Bool";
  TypeTagVariants2[TypeTagVariants2["U8"] = 1] = "U8";
  TypeTagVariants2[TypeTagVariants2["U64"] = 2] = "U64";
  TypeTagVariants2[TypeTagVariants2["U128"] = 3] = "U128";
  TypeTagVariants2[TypeTagVariants2["Address"] = 4] = "Address";
  TypeTagVariants2[TypeTagVariants2["Signer"] = 5] = "Signer";
  TypeTagVariants2[TypeTagVariants2["Vector"] = 6] = "Vector";
  TypeTagVariants2[TypeTagVariants2["Struct"] = 7] = "Struct";
  TypeTagVariants2[TypeTagVariants2["U16"] = 8] = "U16";
  TypeTagVariants2[TypeTagVariants2["U32"] = 9] = "U32";
  TypeTagVariants2[TypeTagVariants2["U256"] = 10] = "U256";
  TypeTagVariants2[TypeTagVariants2["Reference"] = 254] = "Reference";
  TypeTagVariants2[TypeTagVariants2["Generic"] = 255] = "Generic";
  return TypeTagVariants2;
})(TypeTagVariants || {});
var ScriptTransactionArgumentVariants = ((ScriptTransactionArgumentVariants2) => {
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U8"] = 0] = "U8";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U64"] = 1] = "U64";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U128"] = 2] = "U128";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["Address"] = 3] = "Address";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U8Vector"] = 4] = "U8Vector";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["Bool"] = 5] = "Bool";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U16"] = 6] = "U16";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U32"] = 7] = "U32";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U256"] = 8] = "U256";
  return ScriptTransactionArgumentVariants2;
})(ScriptTransactionArgumentVariants || {});
var TransactionPayloadVariants = ((TransactionPayloadVariants2) => {
  TransactionPayloadVariants2[TransactionPayloadVariants2["Script"] = 0] = "Script";
  TransactionPayloadVariants2[TransactionPayloadVariants2["EntryFunction"] = 2] = "EntryFunction";
  TransactionPayloadVariants2[TransactionPayloadVariants2["Multisig"] = 3] = "Multisig";
  return TransactionPayloadVariants2;
})(TransactionPayloadVariants || {});
var TransactionVariants = ((TransactionVariants2) => {
  TransactionVariants2[TransactionVariants2["MultiAgentTransaction"] = 0] = "MultiAgentTransaction";
  TransactionVariants2[TransactionVariants2["FeePayerTransaction"] = 1] = "FeePayerTransaction";
  return TransactionVariants2;
})(TransactionVariants || {});
var TransactionAuthenticatorVariant = ((TransactionAuthenticatorVariant2) => {
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["Ed25519"] = 0] = "Ed25519";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["MultiEd25519"] = 1] = "MultiEd25519";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["MultiAgent"] = 2] = "MultiAgent";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["FeePayer"] = 3] = "FeePayer";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["SingleSender"] = 4] = "SingleSender";
  return TransactionAuthenticatorVariant2;
})(TransactionAuthenticatorVariant || {});
var AccountAuthenticatorVariant = ((AccountAuthenticatorVariant2) => {
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["Ed25519"] = 0] = "Ed25519";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["MultiEd25519"] = 1] = "MultiEd25519";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["SingleKey"] = 2] = "SingleKey";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["MultiKey"] = 3] = "MultiKey";
  return AccountAuthenticatorVariant2;
})(AccountAuthenticatorVariant || {});
var AnyPublicKeyVariant = ((AnyPublicKeyVariant2) => {
  AnyPublicKeyVariant2[AnyPublicKeyVariant2["Ed25519"] = 0] = "Ed25519";
  AnyPublicKeyVariant2[AnyPublicKeyVariant2["Secp256k1"] = 1] = "Secp256k1";
  return AnyPublicKeyVariant2;
})(AnyPublicKeyVariant || {});
var AnySignatureVariant = ((AnySignatureVariant2) => {
  AnySignatureVariant2[AnySignatureVariant2["Ed25519"] = 0] = "Ed25519";
  AnySignatureVariant2[AnySignatureVariant2["Secp256k1"] = 1] = "Secp256k1";
  return AnySignatureVariant2;
})(AnySignatureVariant || {});
var TransactionResponseType = ((TransactionResponseType2) => {
  TransactionResponseType2["Pending"] = "pending_transaction";
  TransactionResponseType2["User"] = "user_transaction";
  TransactionResponseType2["Genesis"] = "genesis_transaction";
  TransactionResponseType2["BlockMetadata"] = "block_metadata_transaction";
  TransactionResponseType2["StateCheckpoint"] = "state_checkpoint_transaction";
  return TransactionResponseType2;
})(TransactionResponseType || {});
var MoveFunctionVisibility = ((MoveFunctionVisibility2) => {
  MoveFunctionVisibility2["PRIVATE"] = "private";
  MoveFunctionVisibility2["PUBLIC"] = "public";
  MoveFunctionVisibility2["FRIEND"] = "friend";
  return MoveFunctionVisibility2;
})(MoveFunctionVisibility || {});
var MoveAbility = ((MoveAbility2) => {
  MoveAbility2["STORE"] = "store";
  MoveAbility2["DROP"] = "drop";
  MoveAbility2["KEY"] = "key";
  MoveAbility2["COPY"] = "copy";
  return MoveAbility2;
})(MoveAbility || {});
var RoleType = ((RoleType2) => {
  RoleType2["VALIDATOR"] = "validator";
  RoleType2["FULL_NODE"] = "full_node";
  return RoleType2;
})(RoleType || {});
var SigningScheme = ((SigningScheme2) => {
  SigningScheme2[SigningScheme2["Ed25519"] = 0] = "Ed25519";
  SigningScheme2[SigningScheme2["MultiEd25519"] = 1] = "MultiEd25519";
  SigningScheme2[SigningScheme2["SingleKey"] = 2] = "SingleKey";
  SigningScheme2[SigningScheme2["MultiKey"] = 3] = "MultiKey";
  return SigningScheme2;
})(SigningScheme || {});
var SigningSchemeInput = ((SigningSchemeInput2) => {
  SigningSchemeInput2[SigningSchemeInput2["Ed25519"] = 0] = "Ed25519";
  SigningSchemeInput2[SigningSchemeInput2["Secp256k1Ecdsa"] = 2] = "Secp256k1Ecdsa";
  return SigningSchemeInput2;
})(SigningSchemeInput || {});
var DeriveScheme = ((DeriveScheme2) => {
  DeriveScheme2[DeriveScheme2["DeriveAuid"] = 251] = "DeriveAuid";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromObject"] = 252] = "DeriveObjectAddressFromObject";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromGuid"] = 253] = "DeriveObjectAddressFromGuid";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromSeed"] = 254] = "DeriveObjectAddressFromSeed";
  DeriveScheme2[DeriveScheme2["DeriveResourceAccountAddress"] = 255] = "DeriveResourceAccountAddress";
  return DeriveScheme2;
})(DeriveScheme || {});
var errors = {
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  429: "Too Many Requests",
  500: "Internal Server Error",
  502: "Bad Gateway",
  503: "Service Unavailable"
};
async function request(options, client) {
  const { url, method, body, contentType, params, overrides } = options;
  const headers = {
    ...overrides == null ? void 0 : overrides.HEADERS,
    "x-aptos-client": `aptos-ts-sdk/${VERSION}`,
    "content-type": contentType != null ? contentType : "application/json"
    /* JSON */
  };
  if (overrides == null ? void 0 : overrides.TOKEN) {
    headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;
  }
  return client.provider({
    url,
    method,
    body,
    params,
    headers,
    overrides
  });
}
async function aptosRequest(options, aptosConfig) {
  var _a;
  const { url, path } = options;
  const fullUrl = `${url}/${path != null ? path : ""}`;
  const response = await request({ ...options, url: fullUrl }, aptosConfig.client);
  const result = {
    status: response.status,
    statusText: response.statusText,
    data: response.data,
    headers: response.headers,
    config: response.config,
    request: response.request,
    url: fullUrl
  };
  if (aptosConfig.isIndexerRequest(url)) {
    const indexerResponse = result.data;
    if (indexerResponse.errors) {
      throw new AptosApiError(
        options,
        result,
        (_a = indexerResponse.errors[0].message) != null ? _a : `Unhandled Error ${response.status} : ${response.statusText}`
      );
    }
    result.data = indexerResponse.data;
  }
  if (result.status >= 200 && result.status < 300) {
    return result;
  }
  const errorMessage = errors[result.status];
  throw new AptosApiError(
    options,
    result,
    errorMessage != null ? errorMessage : `Unhandled Error ${response.status} : ${response.statusText}`
  );
}
var NetworkToIndexerAPI = {
  mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql",
  testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql",
  devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql",
  local: "http://127.0.0.1:8090/v1/graphql"
};
var NetworkToNodeAPI = {
  mainnet: "https://fullnode.mainnet.aptoslabs.com/v1",
  testnet: "https://fullnode.testnet.aptoslabs.com/v1",
  devnet: "https://fullnode.devnet.aptoslabs.com/v1",
  local: "http://127.0.0.1:8080/v1"
};
var NetworkToFaucetAPI = {
  mainnet: "https://faucet.mainnet.aptoslabs.com",
  testnet: "https://faucet.testnet.aptoslabs.com",
  devnet: "https://faucet.devnet.aptoslabs.com",
  local: "http://127.0.0.1:8081"
};
var Network = ((Network2) => {
  Network2["MAINNET"] = "mainnet";
  Network2["TESTNET"] = "testnet";
  Network2["DEVNET"] = "devnet";
  Network2["LOCAL"] = "local";
  Network2["CUSTOM"] = "custom";
  return Network2;
})(Network || {});
var NetworkToChainId = {
  mainnet: 1,
  testnet: 2
};
var DEFAULT_NETWORK = "devnet";
var DEFAULT_MAX_GAS_AMOUNT = 2e5;
var DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
var DEFAULT_TXN_TIMEOUT_SEC = 20;
var APTOS_COIN = "0x1::aptos_coin::AptosCoin";
var RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
var RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
async function get(options) {
  const { aptosConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;
  const url = aptosConfig.getRequestUrl(type);
  return aptosRequest(
    {
      url,
      method: "GET",
      originMethod,
      path,
      contentType: contentType == null ? void 0 : contentType.valueOf(),
      acceptType: acceptType == null ? void 0 : acceptType.valueOf(),
      params,
      overrides: {
        ...aptosConfig.clientConfig,
        ...overrides
      }
    },
    aptosConfig
  );
}
async function getAptosFullNode(options) {
  return get({
    ...options,
    type: 0
    /* FULLNODE */
  });
}
async function paginateWithCursor(options) {
  const out = [];
  let cursor;
  const requestParams = options.params;
  while (true) {
    requestParams.start = cursor;
    const response = await getAptosFullNode({
      aptosConfig: options.aptosConfig,
      originMethod: options.originMethod,
      path: options.path,
      params: requestParams,
      overrides: options.overrides
    });
    cursor = response.headers["x-aptos-cursor"];
    delete response.headers;
    out.push(...response.data);
    if (cursor === null || cursor === void 0) {
      break;
    }
  }
  return out;
}
async function post(options) {
  const { type, originMethod, path, body, acceptType, contentType, params, aptosConfig, overrides } = options;
  const url = aptosConfig.getRequestUrl(type);
  return aptosRequest(
    {
      url,
      method: "POST",
      originMethod,
      path,
      body,
      contentType: contentType == null ? void 0 : contentType.valueOf(),
      acceptType: acceptType == null ? void 0 : acceptType.valueOf(),
      params,
      overrides: {
        ...aptosConfig.clientConfig,
        ...overrides
      }
    },
    aptosConfig
  );
}
async function postAptosFullNode(options) {
  return post({
    ...options,
    type: 0
    /* FULLNODE */
  });
}
async function postAptosIndexer(options) {
  return post({
    ...options,
    type: 1
    /* INDEXER */
  });
}
async function postAptosFaucet(options) {
  return post({
    ...options,
    type: 2
    /* FAUCET */
  });
}
var MAX_U8_NUMBER = 2 ** 8 - 1;
var MAX_U16_NUMBER = 2 ** 16 - 1;
var MAX_U32_NUMBER = 2 ** 32 - 1;
var MAX_U64_BIG_INT = BigInt(2) ** BigInt(64) - BigInt(1);
var MAX_U128_BIG_INT = BigInt(2) ** BigInt(128) - BigInt(1);
var MAX_U256_BIG_INT = BigInt(2) ** BigInt(256) - BigInt(1);
var ParsingError = class extends Error {
  constructor(message, invalidReason) {
    super(message);
    this.invalidReason = invalidReason;
  }
};
var HexInvalidReason = ((HexInvalidReason2) => {
  HexInvalidReason2["TOO_SHORT"] = "too_short";
  HexInvalidReason2["INVALID_LENGTH"] = "invalid_length";
  HexInvalidReason2["INVALID_HEX_CHARS"] = "invalid_hex_chars";
  return HexInvalidReason2;
})(HexInvalidReason || {});
var Hex = class {
  constructor(data) {
    this.data = data;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromString(str) {
    let input = str;
    if (input.startsWith("0x")) {
      input = input.slice(2);
    }
    if (input.length === 0) {
      throw new ParsingError(
        "Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.",
        "too_short"
        /* TOO_SHORT */
      );
    }
    if (input.length % 2 !== 0) {
      throw new ParsingError(
        "Hex string must be an even number of hex characters.",
        "invalid_length"
        /* INVALID_LENGTH */
      );
    }
    try {
      return new Hex(hexToBytes(input));
    } catch (e) {
      const error = e;
      throw new ParsingError(
        `Hex string contains invalid hex characters: ${error.message}`,
        "invalid_hex_chars"
        /* INVALID_HEX_CHARS */
      );
    }
  }
  static fromHexInput(hexInput) {
    if (hexInput instanceof Uint8Array)
      return new Hex(hexInput);
    return Hex.fromString(hexInput);
  }
  static isValid(str) {
    try {
      Hex.fromString(str);
      return { valid: true };
    } catch (e) {
      const error = e;
      return {
        valid: false,
        invalidReason: error.invalidReason,
        invalidReasonMessage: error.message
      };
    }
  }
  equals(other) {
    if (this.data.length !== other.data.length)
      return false;
    return this.data.every((value, index) => value === other.data[index]);
  }
};
var Serializable = class {
  bcsToBytes() {
    const serializer = new Serializer();
    this.serialize(serializer);
    return serializer.toUint8Array();
  }
  bcsToHex() {
    const bcsBytes = this.bcsToBytes();
    return Hex.fromHexInput(bcsBytes);
  }
};
var Serializer = class {
  constructor(length = 64) {
    if (length <= 0) {
      throw new Error("Length needs to be greater than 0");
    }
    this.buffer = new ArrayBuffer(length);
    this.offset = 0;
  }
  ensureBufferWillHandleSize(bytes3) {
    while (this.buffer.byteLength < this.offset + bytes3) {
      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
      this.buffer = newBuffer;
    }
  }
  appendToBuffer(values) {
    this.ensureBufferWillHandleSize(values.length);
    new Uint8Array(this.buffer, this.offset).set(values);
    this.offset += values.length;
  }
  serializeWithFunction(fn, bytesLength, value) {
    this.ensureBufferWillHandleSize(bytesLength);
    const dv = new DataView(this.buffer, this.offset);
    fn.apply(dv, [0, value, true]);
    this.offset += bytesLength;
  }
  serializeStr(value) {
    const textEncoder = new TextEncoder();
    this.serializeBytes(textEncoder.encode(value));
  }
  serializeBytes(value) {
    this.serializeU32AsUleb128(value.length);
    this.appendToBuffer(value);
  }
  serializeFixedBytes(value) {
    this.appendToBuffer(value);
  }
  serializeBool(value) {
    ensureBoolean(value);
    const byteValue = value ? 1 : 0;
    this.appendToBuffer(new Uint8Array([byteValue]));
  }
  serializeU8(value) {
    this.appendToBuffer(new Uint8Array([value]));
  }
  serializeU16(value) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
  }
  serializeU32(value) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
  }
  serializeU64(value) {
    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);
    const high = BigInt(value) >> BigInt(32);
    this.serializeU32(Number(low));
    this.serializeU32(Number(high));
  }
  serializeU128(value) {
    const low = BigInt(value) & MAX_U64_BIG_INT;
    const high = BigInt(value) >> BigInt(64);
    this.serializeU64(low);
    this.serializeU64(high);
  }
  serializeU256(value) {
    const low = BigInt(value) & MAX_U128_BIG_INT;
    const high = BigInt(value) >> BigInt(128);
    this.serializeU128(low);
    this.serializeU128(high);
  }
  serializeU32AsUleb128(val) {
    let value = val;
    const valueArray = [];
    while (value >>> 7 !== 0) {
      valueArray.push(value & 127 | 128);
      value >>>= 7;
    }
    valueArray.push(value);
    this.appendToBuffer(new Uint8Array(valueArray));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(value) {
    value.serialize(this);
  }
  serializeVector(values) {
    this.serializeU32AsUleb128(values.length);
    values.forEach((item) => {
      item.serialize(this);
    });
  }
};
__decorateClass([
  checkNumberRange(0, MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", 1);
__decorateClass([
  checkNumberRange(0, MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U256_BIG_INT)
], Serializer.prototype, "serializeU256", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", 1);
function ensureBoolean(value) {
  if (typeof value !== "boolean") {
    throw new Error(`${value} is not a boolean value`);
  }
}
var outOfRangeErrorMessage = (value, min, max) => `${value} is out of range: [${min}, ${max}]`;
function validateNumberInRange(value, minValue, maxValue) {
  const valueBigInt = BigInt(value);
  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {
    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));
  }
}
function checkNumberRange(minValue, maxValue) {
  return (target, propertyKey, descriptor) => {
    const childFunction = descriptor.value;
    descriptor.value = function deco(value) {
      validateNumberInRange(value, minValue, maxValue);
      return childFunction.apply(this, [value]);
    };
    return descriptor;
  };
}
var AddressInvalidReason = ((AddressInvalidReason2) => {
  AddressInvalidReason2["INCORRECT_NUMBER_OF_BYTES"] = "incorrect_number_of_bytes";
  AddressInvalidReason2["INVALID_HEX_CHARS"] = "invalid_hex_chars";
  AddressInvalidReason2["TOO_SHORT"] = "too_short";
  AddressInvalidReason2["TOO_LONG"] = "too_long";
  AddressInvalidReason2["LEADING_ZERO_X_REQUIRED"] = "leading_zero_x_required";
  AddressInvalidReason2["LONG_FORM_REQUIRED_UNLESS_SPECIAL"] = "long_form_required_unless_special";
  AddressInvalidReason2["INVALID_PADDING_ZEROES"] = "INVALID_PADDING_ZEROES";
  return AddressInvalidReason2;
})(AddressInvalidReason || {});
var _AccountAddress = class extends Serializable {
  constructor(args) {
    super();
    if (args.data.length !== _AccountAddress.LENGTH) {
      throw new ParsingError(
        "AccountAddress data should be exactly 32 bytes long",
        "incorrect_number_of_bytes"
        /* INCORRECT_NUMBER_OF_BYTES */
      );
    }
    this.data = args.data;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let hex = bytesToHex(this.data);
    if (this.isSpecial()) {
      hex = hex[hex.length - 1];
    }
    return hex;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* Address */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeFixedBytes(_AccountAddress.LENGTH);
    return new _AccountAddress({ data: bytes3 });
  }
  static fromString(input) {
    if (!input.startsWith("0x")) {
      throw new ParsingError(
        "Hex string must start with a leading 0x.",
        "leading_zero_x_required"
        /* LEADING_ZERO_X_REQUIRED */
      );
    }
    const address = _AccountAddress.fromStringRelaxed(input);
    if (input.length !== _AccountAddress.LONG_STRING_LENGTH + 2) {
      if (!address.isSpecial()) {
        throw new ParsingError(
          `The given hex string ${address} is not a special address, it must be represented as 0x + 64 chars.`,
          "long_form_required_unless_special"
          /* LONG_FORM_REQUIRED_UNLESS_SPECIAL */
        );
      } else if (input.length !== 3) {
        throw new ParsingError(
          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,
          "INVALID_PADDING_ZEROES"
          /* INVALID_PADDING_ZEROES */
        );
      }
    }
    return address;
  }
  static fromStringRelaxed(input) {
    let parsedInput = input;
    if (input.startsWith("0x")) {
      parsedInput = input.slice(2);
    }
    if (parsedInput.length === 0) {
      throw new ParsingError(
        "Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.",
        "too_short"
        /* TOO_SHORT */
      );
    }
    if (parsedInput.length > 64) {
      throw new ParsingError(
        "Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.",
        "too_long"
        /* TOO_LONG */
      );
    }
    let addressBytes;
    try {
      addressBytes = hexToBytes(parsedInput.padStart(64, "0"));
    } catch (e) {
      const error = e;
      throw new ParsingError(
        `Hex characters are invalid: ${error.message}`,
        "invalid_hex_chars"
        /* INVALID_HEX_CHARS */
      );
    }
    return new _AccountAddress({ data: addressBytes });
  }
  static fromHexInput(input) {
    if (input instanceof Uint8Array) {
      return new _AccountAddress({ data: input });
    }
    return _AccountAddress.fromString(input);
  }
  static fromHexInputRelaxed(hexInput) {
    if (hexInput instanceof Uint8Array) {
      return new _AccountAddress({ data: hexInput });
    }
    return _AccountAddress.fromStringRelaxed(hexInput);
  }
  static isValid(args) {
    try {
      if (args.relaxed) {
        _AccountAddress.fromStringRelaxed(args.input);
      } else {
        _AccountAddress.fromString(args.input);
      }
      return { valid: true };
    } catch (e) {
      const error = e;
      return {
        valid: false,
        invalidReason: error.invalidReason,
        invalidReasonMessage: error.message
      };
    }
  }
  equals(other) {
    if (this.data.length !== other.data.length)
      return false;
    return this.data.every((value, index) => value === other.data[index]);
  }
};
var AccountAddress = _AccountAddress;
AccountAddress.LENGTH = 32;
AccountAddress.LONG_STRING_LENGTH = 64;
AccountAddress.ZERO = _AccountAddress.fromString("0x0");
AccountAddress.ONE = _AccountAddress.fromString("0x1");
AccountAddress.TWO = _AccountAddress.fromString("0x2");
AccountAddress.THREE = _AccountAddress.fromString("0x3");
AccountAddress.FOUR = _AccountAddress.fromString("0x4");
var Deserializer = class {
  constructor(data) {
    this.buffer = new ArrayBuffer(data.length);
    new Uint8Array(this.buffer).set(data, 0);
    this.offset = 0;
  }
  read(length) {
    if (this.offset + length > this.buffer.byteLength) {
      throw new Error("Reached to the end of buffer");
    }
    const bytes3 = this.buffer.slice(this.offset, this.offset + length);
    this.offset += length;
    return bytes3;
  }
  deserializeStr() {
    const value = this.deserializeBytes();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(value);
  }
  deserializeBytes() {
    const len = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(len));
  }
  deserializeFixedBytes(len) {
    return new Uint8Array(this.read(len));
  }
  deserializeBool() {
    const bool2 = new Uint8Array(this.read(1))[0];
    if (bool2 !== 1 && bool2 !== 0) {
      throw new Error("Invalid boolean value");
    }
    return bool2 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    const low = this.deserializeU32();
    const high = this.deserializeU32();
    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));
  }
  deserializeU128() {
    const low = this.deserializeU64();
    const high = this.deserializeU64();
    return BigInt(high << BigInt(64) | low);
  }
  deserializeU256() {
    const low = this.deserializeU128();
    const high = this.deserializeU128();
    return BigInt(high << BigInt(128) | low);
  }
  deserializeUleb128AsU32() {
    let value = BigInt(0);
    let shift = 0;
    while (value < MAX_U32_NUMBER) {
      const byte = this.deserializeU8();
      value |= BigInt(byte & 127) << BigInt(shift);
      if ((byte & 128) === 0) {
        break;
      }
      shift += 7;
    }
    if (value > MAX_U32_NUMBER) {
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    }
    return Number(value);
  }
  deserialize(cls) {
    return cls.deserialize(this);
  }
  deserializeVector(cls) {
    const length = this.deserializeUleb128AsU32();
    const vector = new Array();
    for (let i = 0; i < length; i += 1) {
      vector.push(this.deserialize(cls));
    }
    return vector;
  }
};
var FixedBytes = class extends Serializable {
  constructor(value) {
    super();
    this.value = Hex.fromHexInput(value).toUint8Array();
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(serializer) {
    serializer.serialize(this);
  }
  serializeForScriptFunction(serializer) {
    serializer.serialize(this);
  }
  static deserialize(deserializer, length) {
    const bytes3 = deserializer.deserializeFixedBytes(length);
    return new FixedBytes(bytes3);
  }
};
var EntryFunctionBytes = class extends Serializable {
  constructor(value) {
    super();
    this.value = new FixedBytes(value);
  }
  serialize(serializer) {
    serializer.serialize(this.value);
  }
  serializeForEntryFunction(serializer) {
    serializer.serializeU32AsUleb128(this.value.value.length);
    serializer.serialize(this);
  }
  static deserialize(deserializer, length) {
    const fixedBytes = FixedBytes.deserialize(deserializer, length);
    return new EntryFunctionBytes(fixedBytes.value);
  }
};
var Bool = class extends Serializable {
  constructor(value) {
    super();
    ensureBoolean(value);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeBool(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      5
      /* Bool */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new Bool(deserializer.deserializeBool());
  }
};
var U8 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U8_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU8(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* U8 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U8(deserializer.deserializeU8());
  }
};
var U16 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U16_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU16(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      6
      /* U16 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U16(deserializer.deserializeU16());
  }
};
var U32 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U32_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      7
      /* U32 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U32(deserializer.deserializeU32());
  }
};
var U64 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU64(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* U64 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U64(deserializer.deserializeU64());
  }
};
var U128 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU128(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* U128 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U128(deserializer.deserializeU128());
  }
};
var U256 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU256(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      8
      /* U256 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U256(deserializer.deserializeU256());
  }
};
var MoveVector = class extends Serializable {
  constructor(values) {
    super();
    this.values = values;
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    const isU8 = this.values[0] instanceof U8;
    if (!isU8) {
      throw new Error("Script function arguments only accept u8 vectors");
    }
    serializer.serializeU32AsUleb128(
      4
      /* U8Vector */
    );
    serializer.serialize(this);
  }
  static U8(values) {
    let numbers;
    if (Array.isArray(values) && typeof values[0] === "number") {
      numbers = values;
    } else if (typeof values === "string") {
      const hex = Hex.fromHexInput(values);
      numbers = Array.from(hex.toUint8Array());
    } else if (values instanceof Uint8Array) {
      numbers = Array.from(values);
    } else {
      throw new Error("Invalid input type");
    }
    return new MoveVector(numbers.map((v) => new U8(v)));
  }
  static U16(values) {
    return new MoveVector(values.map((v) => new U16(v)));
  }
  static U32(values) {
    return new MoveVector(values.map((v) => new U32(v)));
  }
  static U64(values) {
    return new MoveVector(values.map((v) => new U64(v)));
  }
  static U128(values) {
    return new MoveVector(values.map((v) => new U128(v)));
  }
  static U256(values) {
    return new MoveVector(values.map((v) => new U256(v)));
  }
  static Bool(values) {
    return new MoveVector(values.map((v) => new Bool(v)));
  }
  static MoveString(values) {
    return new MoveVector(values.map((v) => new MoveString(v)));
  }
  serialize(serializer) {
    serializer.serializeVector(this.values);
  }
  static deserialize(deserializer, cls) {
    const length = deserializer.deserializeUleb128AsU32();
    const values = new Array();
    for (let i = 0; i < length; i += 1) {
      values.push(cls.deserialize(deserializer));
    }
    return new MoveVector(values);
  }
};
var MoveString = class extends Serializable {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeStr(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    const vectorU8 = MoveVector.U8(this.bcsToBytes());
    vectorU8.serializeForScriptFunction(serializer);
  }
  static deserialize(deserializer) {
    return new MoveString(deserializer.deserializeStr());
  }
};
var MoveOption = class extends Serializable {
  constructor(value) {
    super();
    if (typeof value !== "undefined" && value !== null) {
      this.vec = new MoveVector([value]);
    } else {
      this.vec = new MoveVector([]);
    }
    [this.value] = this.vec.values;
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  unwrap() {
    if (!this.isSome()) {
      throw new Error("Called unwrap on a MoveOption with no value");
    } else {
      return this.vec.values[0];
    }
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(serializer) {
    this.vec.serialize(serializer);
  }
  static U8(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U8(value) : void 0);
  }
  static U16(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U16(value) : void 0);
  }
  static U32(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U32(value) : void 0);
  }
  static U64(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U64(value) : void 0);
  }
  static U128(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U128(value) : void 0);
  }
  static U256(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U256(value) : void 0);
  }
  static Bool(value) {
    return new MoveOption(value !== null && value !== void 0 ? new Bool(value) : void 0);
  }
  static MoveString(value) {
    return new MoveOption(value !== null && value !== void 0 ? new MoveString(value) : void 0);
  }
  static deserialize(deserializer, cls) {
    const vector = MoveVector.deserialize(deserializer, cls);
    return new MoveOption(vector.values[0]);
  }
};
var PublicKey = class extends Serializable {
};
var PrivateKey = class extends Serializable {
};
var Signature = class extends Serializable {
};
var _Ed25519PublicKey = class extends PublicKey {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Ed25519PublicKey.LENGTH) {
      throw new Error(`PublicKey length should be ${_Ed25519PublicKey.LENGTH}`);
    }
    this.key = hex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    const rawMessage = Hex.fromHexInput(message).toUint8Array();
    const rawSignature = Hex.fromHexInput(signature.toUint8Array()).toUint8Array();
    return import_tweetnacl.default.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Ed25519PublicKey(bytes3);
  }
  static load(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Ed25519PublicKey(bytes3);
  }
};
var Ed25519PublicKey = _Ed25519PublicKey;
Ed25519PublicKey.LENGTH = 32;
var _Ed25519PrivateKey = class extends PrivateKey {
  constructor(hexInput) {
    super();
    const privateKeyHex = Hex.fromHexInput(hexInput);
    if (privateKeyHex.toUint8Array().length !== _Ed25519PrivateKey.LENGTH) {
      throw new Error(`PrivateKey length should be ${_Ed25519PrivateKey.LENGTH}`);
    }
    this.signingKeyPair = import_tweetnacl.default.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, _Ed25519PrivateKey.LENGTH));
  }
  toUint8Array() {
    return this.signingKeyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH);
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  sign(message) {
    const hex = Hex.fromHexInput(message);
    const signature = import_tweetnacl.default.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);
    return new Ed25519Signature(signature);
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Ed25519PrivateKey(bytes3);
  }
  static generate() {
    const keyPair = import_tweetnacl.default.sign.keyPair();
    return new _Ed25519PrivateKey(keyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH));
  }
  publicKey() {
    const bytes3 = this.signingKeyPair.publicKey;
    return new Ed25519PublicKey(bytes3);
  }
};
var Ed25519PrivateKey = _Ed25519PrivateKey;
Ed25519PrivateKey.LENGTH = 32;
var _Ed25519Signature = class extends Signature {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Ed25519Signature.LENGTH) {
      throw new Error(`Signature length should be ${_Ed25519Signature.LENGTH}`);
    }
    this.data = hex;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(serializer) {
    serializer.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Ed25519Signature(bytes3);
  }
  static load(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Ed25519Signature(bytes3);
  }
};
var Ed25519Signature = _Ed25519Signature;
Ed25519Signature.LENGTH = 64;
var _MultiEd25519PublicKey = class extends PublicKey {
  constructor(args) {
    super();
    const { publicKeys, threshold } = args;
    if (publicKeys.length > _MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < _MultiEd25519PublicKey.MIN_KEYS) {
      throw new Error(
        `Must have between ${_MultiEd25519PublicKey.MIN_KEYS} and ${_MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`
      );
    }
    if (threshold < _MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {
      throw new Error(
        `Threshold must be between ${_MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`
      );
    }
    this.publicKeys = publicKeys;
    this.threshold = threshold;
  }
  toUint8Array() {
    const bytes3 = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);
    this.publicKeys.forEach((k, i) => {
      bytes3.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);
    });
    bytes3[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;
    return bytes3;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(args) {
    throw new Error("TODO - Method not implemented.");
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    const threshold = bytes3[bytes3.length - 1];
    const keys = [];
    for (let i = 0; i < bytes3.length - 1; i += Ed25519PublicKey.LENGTH) {
      const begin = i;
      keys.push(new Ed25519PublicKey(bytes3.subarray(begin, begin + Ed25519PublicKey.LENGTH)));
    }
    return new _MultiEd25519PublicKey({ publicKeys: keys, threshold });
  }
};
var MultiEd25519PublicKey = _MultiEd25519PublicKey;
MultiEd25519PublicKey.MAX_KEYS = 32;
MultiEd25519PublicKey.MIN_KEYS = 2;
MultiEd25519PublicKey.MIN_THRESHOLD = 1;
var _MultiEd25519Signature = class extends Signature {
  constructor(args) {
    super();
    const { signatures, bitmap } = args;
    if (bitmap.length !== _MultiEd25519Signature.BITMAP_LEN) {
      throw new Error(`"bitmap" length should be ${_MultiEd25519Signature.BITMAP_LEN}`);
    }
    if (signatures.length > _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
      throw new Error(
        `The number of signatures cannot be greater than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`
      );
    }
    this.signatures = signatures;
    this.bitmap = bitmap;
  }
  toUint8Array() {
    const bytes3 = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature.BITMAP_LEN);
    this.signatures.forEach((k, i) => {
      bytes3.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);
    });
    bytes3.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);
    return bytes3;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  static createBitmap(args) {
    const { bits } = args;
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit) => {
      if (bit >= _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
        throw new Error(`Cannot have a signature larger than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error("Duplicate bits detected.");
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    const bitmap = bytes3.subarray(bytes3.length - 4);
    const signatures = [];
    for (let i = 0; i < bytes3.length - bitmap.length; i += Ed25519Signature.LENGTH) {
      const begin = i;
      signatures.push(new Ed25519Signature(bytes3.subarray(begin, begin + Ed25519Signature.LENGTH)));
    }
    return new _MultiEd25519Signature({ signatures, bitmap });
  }
};
var MultiEd25519Signature = _MultiEd25519Signature;
MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED = 32;
MultiEd25519Signature.BITMAP_LEN = 4;
var _Secp256k1PublicKey = class extends PublicKey {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Secp256k1PublicKey.LENGTH) {
      throw new Error(`PublicKey length should be ${_Secp256k1PublicKey.LENGTH}`);
    }
    this.key = hex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    const msgHex = Hex.fromHexInput(message).toUint8Array();
    const sha3Message = sha3_256(msgHex);
    const rawSignature = signature.toUint8Array();
    return secp256k1.verify(rawSignature, sha3Message, this.toUint8Array());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Secp256k1PublicKey(bytes3);
  }
  static load(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Secp256k1PublicKey(bytes3);
  }
};
var Secp256k1PublicKey = _Secp256k1PublicKey;
Secp256k1PublicKey.LENGTH = 65;
var _Secp256k1PrivateKey = class extends PrivateKey {
  constructor(hexInput) {
    super();
    const privateKeyHex = Hex.fromHexInput(hexInput);
    if (privateKeyHex.toUint8Array().length !== _Secp256k1PrivateKey.LENGTH) {
      throw new Error(`PrivateKey length should be ${_Secp256k1PrivateKey.LENGTH}`);
    }
    this.key = privateKeyHex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  sign(message) {
    const msgHex = Hex.fromHexInput(message);
    const sha3Message = sha3_256(msgHex.toUint8Array());
    const signature = secp256k1.sign(sha3Message, this.key.toUint8Array());
    return new Secp256k1Signature(signature.toCompactRawBytes());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Secp256k1PrivateKey(bytes3);
  }
  static generate() {
    const hexInput = secp256k1.utils.randomPrivateKey();
    return new _Secp256k1PrivateKey(hexInput);
  }
  publicKey() {
    const bytes3 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new Secp256k1PublicKey(bytes3);
  }
};
var Secp256k1PrivateKey = _Secp256k1PrivateKey;
Secp256k1PrivateKey.LENGTH = 32;
var _Secp256k1Signature = class extends Signature {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Secp256k1Signature.LENGTH) {
      throw new Error(`Signature length should be ${_Secp256k1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);
    }
    this.data = hex;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(serializer) {
    serializer.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const hex = deserializer.deserializeBytes();
    return new _Secp256k1Signature(hex);
  }
  static load(deserializer) {
    const bytes3 = deserializer.deserializeBytes();
    return new _Secp256k1Signature(bytes3);
  }
};
var Secp256k1Signature = _Secp256k1Signature;
Secp256k1Signature.LENGTH = 64;
var AnyPublicKey = class extends PublicKey {
  constructor(publicKey) {
    super();
    this.publicKey = publicKey;
  }
  toUint8Array() {
    return this.publicKey.toUint8Array();
  }
  toString() {
    return this.publicKey.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    return this.publicKey.verifySignature({ message, signature });
  }
  serialize(serializer) {
    if (this.publicKey instanceof Ed25519PublicKey) {
      serializer.serializeU32AsUleb128(
        0
        /* Ed25519 */
      );
      this.publicKey.serialize(serializer);
    } else if (this.publicKey instanceof Secp256k1PublicKey) {
      serializer.serializeU32AsUleb128(
        1
        /* Secp256k1 */
      );
      this.publicKey.serialize(serializer);
    } else {
      throw new Error("Unknown public key type");
    }
  }
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));
      case 1:
        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);
    }
  }
};
var MultiKey = class extends PublicKey {
  constructor(args) {
    super();
    const { publicKeys, signaturesRequired } = args;
    if (signaturesRequired < 1) {
      throw new Error("The number of required signatures needs to be greater then 0");
    }
    if (publicKeys.length < signaturesRequired) {
      throw new Error(
        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`
      );
    }
    const keys = [];
    publicKeys.forEach((publicKey) => {
      if (publicKey instanceof AnyPublicKey) {
        keys.push(publicKey);
      } else {
        keys.push(new AnyPublicKey(publicKey));
      }
    });
    this.publicKeys = keys;
    this.signaturesRequired = signaturesRequired;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  createBitmap(args) {
    const { bits } = args;
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit, idx) => {
      if (idx + 1 > this.publicKeys.length) {
        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error(`Duplicate bit ${bit} detected.`);
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(args) {
    throw new Error("not implemented");
  }
  serialize(serializer) {
    serializer.serializeVector(this.publicKeys);
    serializer.serializeU8(this.signaturesRequired);
  }
  static deserialize(deserializer) {
    const keys = deserializer.deserializeVector(AnyPublicKey);
    const signaturesRequired = deserializer.deserializeU8();
    return new MultiKey({ publicKeys: keys, signaturesRequired });
  }
};
var _AuthenticationKey = class extends Serializable {
  constructor(args) {
    super();
    const { data } = args;
    const hex = Hex.fromHexInput(data);
    if (hex.toUint8Array().length !== _AuthenticationKey.LENGTH) {
      throw new Error(`Authentication Key length should be ${_AuthenticationKey.LENGTH}`);
    }
    this.data = hex;
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes3 = deserializer.deserializeFixedBytes(_AuthenticationKey.LENGTH);
    return new _AuthenticationKey({ data: bytes3 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromPublicKeyAndScheme(args) {
    const { publicKey, scheme } = args;
    let authKeyBytes;
    switch (scheme) {
      case 3:
      case 2: {
        const singleKeyBytes = publicKey.bcsToBytes();
        authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);
        break;
      }
      case 0:
      case 1: {
        const ed25519PublicKeyBytes = publicKey.toUint8Array();
        const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();
        authKeyBytes = new Uint8Array([...inputBytes, scheme]);
        break;
      }
      default:
        throw new Error(`Scheme ${scheme} is not supported`);
    }
    const hash3 = sha3_256.create();
    hash3.update(authKeyBytes);
    const hashDigest = hash3.digest();
    return new _AuthenticationKey({ data: hashDigest });
  }
  static fromPublicKey(args) {
    const { publicKey } = args;
    let scheme;
    if (publicKey instanceof Ed25519PublicKey) {
      scheme = 0 .valueOf();
    } else if (publicKey instanceof MultiEd25519PublicKey) {
      scheme = 1 .valueOf();
    } else if (publicKey instanceof AnyPublicKey) {
      scheme = 2 .valueOf();
    } else if (publicKey instanceof MultiKey) {
      scheme = 3 .valueOf();
    } else {
      throw new Error("No supported authentication scheme for public key");
    }
    return _AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme });
  }
  derivedAddress() {
    return new AccountAddress({ data: this.data.toUint8Array() });
  }
};
var AuthenticationKey = _AuthenticationKey;
AuthenticationKey.LENGTH = 32;
var APTOS_PATH_REGEX = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var KeyType = ((KeyType2) => {
  KeyType2["ED25519"] = "ed25519 seed";
  return KeyType2;
})(KeyType || {});
var HARDENED_OFFSET = 2147483648;
var deriveKey = (hashSeed, data) => {
  const digest = hmac2.create(sha512, hashSeed).update(data).digest();
  return {
    key: digest.slice(0, 32),
    chainCode: digest.slice(32)
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const buffer = new ArrayBuffer(4);
  new DataView(buffer).setUint32(0, index);
  const indexBytes = new Uint8Array(buffer);
  const zero = new Uint8Array([0]);
  const data = new Uint8Array([...zero, ...key, ...indexBytes]);
  return deriveKey(chainCode, data);
};
var removeApostrophes = (val) => val.replace("'", "");
var splitPath = (path) => path.split("/").slice(1).map(removeApostrophes);
var isValidPath = (path) => {
  if (!APTOS_PATH_REGEX.test(path)) {
    return false;
  }
  return !splitPath(path).some(Number.isNaN);
};
var mnemonicToSeed = (mnemonic) => {
  const normalizedMnemonic = mnemonic.trim().split(/\s+/).map((part) => part.toLowerCase()).join(" ");
  return bip39.mnemonicToSeedSync(normalizedMnemonic);
};
var derivePrivateKeyFromMnemonic = (keyType, path, seedPhrase, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = deriveKey(keyType, mnemonicToSeed(seedPhrase));
  const segments = splitPath(path).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });
};
var Account = class {
  constructor(args) {
    const { privateKey, address, legacy } = args;
    this.publicKey = privateKey.publicKey();
    if (this.publicKey instanceof Ed25519PublicKey) {
      if (legacy) {
        this.signingScheme = 0;
      } else {
        this.publicKey = new AnyPublicKey(this.publicKey);
        this.signingScheme = 2;
      }
    } else if (this.publicKey instanceof MultiEd25519PublicKey) {
      this.signingScheme = 1;
    } else if (this.publicKey instanceof Secp256k1PublicKey) {
      this.publicKey = new AnyPublicKey(this.publicKey);
      this.signingScheme = 2;
    } else {
      throw new Error("Can not create new Account, unsupported public key type");
    }
    this.privateKey = privateKey;
    this.accountAddress = address;
  }
  static generate(args) {
    let privateKey;
    switch (args == null ? void 0 : args.scheme) {
      case 2:
        privateKey = Secp256k1PrivateKey.generate();
        break;
      default:
        privateKey = Ed25519PrivateKey.generate();
    }
    let publicKey = privateKey.publicKey();
    if (!(args == null ? void 0 : args.legacy)) {
      publicKey = new AnyPublicKey(privateKey.publicKey());
    }
    const address = new AccountAddress({
      data: Account.authKey({
        publicKey
      }).toUint8Array()
    });
    return new Account({ privateKey, address, legacy: args == null ? void 0 : args.legacy });
  }
  static fromPrivateKeyAndAddress(args) {
    const { privateKey, address, legacy } = args;
    return new Account({ privateKey, address, legacy });
  }
  static fromDerivationPath(args) {
    const { path, mnemonic } = args;
    const { key } = derivePrivateKeyFromMnemonic("ed25519 seed", path, mnemonic);
    const privateKey = new Ed25519PrivateKey(key);
    const publicKey = privateKey.publicKey();
    const authKey = Account.authKey({ publicKey });
    const address = new AccountAddress({ data: authKey.toUint8Array() });
    return new Account({ privateKey, address, legacy: true });
  }
  static authKey(args) {
    const { publicKey } = args;
    const authKey = AuthenticationKey.fromPublicKey({ publicKey });
    return authKey.data;
  }
  sign(data) {
    return this.privateKey.sign(data);
  }
  verifySignature(args) {
    const { message, signature } = args;
    const rawMessage = Hex.fromHexInput(message).toUint8Array();
    return this.publicKey.verifySignature({ message: rawMessage, signature });
  }
};
var CurrentTokenOwnershipFieldsFragmentDoc = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var TokenActivitiesFieldsFragmentDoc = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var GetAccountCoinsCount = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountCoinsData = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var GetAccountCollectionsWithOwnedTokens = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var GetAccountOwnedObjects = `
    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var GetAccountOwnedTokens = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountOwnedTokensByTokenData = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountOwnedTokensFromCollection = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountTokensCount = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountTransactionsCount = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var GetChainTopUserTransactions = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var GetCollectionData = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
var GetCurrentFungibleAssetBalances = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var GetDelegatedStakingActivities = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var GetEvents = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
  }
}
    `;
var GetFungibleAssetActivities = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var GetFungibleAssetMetadata = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
  }
}
    `;
var GetNumberOfDelegators = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp!, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var GetProcessorStatus = `
    query getProcessorStatus {
  processor_status {
    last_success_version
    processor
    last_updated
  }
}
    `;
var GetTokenActivity = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
var GetCurrentTokenOwnership = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTokenData = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
async function getLedgerInfo(args) {
  const { aptosConfig } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getLedgerInfo",
    path: ""
  });
  return data;
}
async function getBlockByVersion(args) {
  const { aptosConfig, ledgerVersion, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getBlockByVersion",
    path: `blocks/by_version/${ledgerVersion}`,
    params: { with_transactions: options == null ? void 0 : options.withTransactions }
  });
  return data;
}
async function getBlockByHeight(args) {
  const { aptosConfig, blockHeight, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getBlockByHeight",
    path: `blocks/by_height/${blockHeight}`,
    params: { with_transactions: options == null ? void 0 : options.withTransactions }
  });
  return data;
}
async function getTableItem(args) {
  const { aptosConfig, handle, data, options } = args;
  const response = await postAptosFullNode({
    aptosConfig,
    originMethod: "getTableItem",
    path: `tables/${handle}/item`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion },
    body: data
  });
  return response.data;
}
async function view(args) {
  var _a, _b;
  const { aptosConfig, payload, options } = args;
  const { data } = await postAptosFullNode({
    aptosConfig,
    originMethod: "view",
    path: "view",
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion },
    body: {
      function: payload.function,
      type_arguments: (_a = payload.typeArguments) != null ? _a : [],
      arguments: (_b = payload.functionArguments) != null ? _b : []
    }
  });
  return data;
}
async function getChainTopUserTransactions(args) {
  const { aptosConfig, limit } = args;
  const graphqlQuery = {
    query: GetChainTopUserTransactions,
    variables: { limit }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getChainTopUserTransactions"
  });
  return data.user_transactions;
}
async function queryIndexer(args) {
  const { aptosConfig, query, originMethod } = args;
  const { data } = await postAptosIndexer({
    aptosConfig,
    originMethod: originMethod != null ? originMethod : "queryIndexer",
    path: "",
    body: query,
    overrides: { WITH_CREDENTIALS: false }
  });
  return data;
}
async function getProcessorStatuses(args) {
  const { aptosConfig } = args;
  const graphqlQuery = {
    query: GetProcessorStatus
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getProcessorStatuses"
  });
  return data.processor_status;
}
async function getIndexerLastSuccessVersion(args) {
  const response = await getProcessorStatuses({ aptosConfig: args.aptosConfig });
  return response[0].last_success_version;
}
var cache = /* @__PURE__ */ new Map();
function memoizeAsync(func, key, ttlMs) {
  return async (...args) => {
    if (cache.has(key)) {
      const { value, timestamp } = cache.get(key);
      if (ttlMs === void 0 || Date.now() - timestamp <= ttlMs) {
        return value;
      }
    }
    const result = await func(...args);
    cache.set(key, { value: result, timestamp: Date.now() });
    return result;
  };
}
async function getInfo(args) {
  const { aptosConfig, accountAddress } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getInfo",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}`
  });
  return data;
}
async function getModules(args) {
  var _a;
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getModules",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/modules`,
    params: {
      ledger_version: options == null ? void 0 : options.ledgerVersion,
      start: options == null ? void 0 : options.offset,
      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 1e3
    }
  });
}
async function getModule(args) {
  var _a;
  if (((_a = args.options) == null ? void 0 : _a.ledgerVersion) !== void 0) {
    return getModuleInner(args);
  }
  return memoizeAsync(
    async () => getModuleInner(args),
    `module-${args.accountAddress}-${args.moduleName}`,
    1e3 * 60 * 5
  )();
}
async function getModuleInner(args) {
  const { aptosConfig, accountAddress, moduleName, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getModule",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/module/${moduleName}`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion }
  });
  return data;
}
async function getTransactions(args) {
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getTransactions",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/transactions`,
    params: { start: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
  });
}
async function getResources(args) {
  var _a;
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getResources",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resources`,
    params: {
      ledger_version: options == null ? void 0 : options.ledgerVersion,
      start: options == null ? void 0 : options.offset,
      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 999
    }
  });
}
async function getResource(args) {
  const { aptosConfig, accountAddress, resourceType, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getResource",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resource/${resourceType}`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion }
  });
  return data.data;
}
async function lookupOriginalAccountAddress(args) {
  const { aptosConfig, authenticationKey, options } = args;
  const resource = await getResource({
    aptosConfig,
    accountAddress: "0x1",
    resourceType: "0x1::account::OriginatingAddress",
    options
  });
  const {
    address_map: { handle }
  } = resource;
  try {
    const originalAddress = await getTableItem({
      aptosConfig,
      handle,
      data: {
        key: Hex.fromHexInput(authenticationKey).toString(),
        key_type: "address",
        value_type: "address"
      },
      options
    });
    return AccountAddress.fromHexInput(originalAddress);
  } catch (err) {
    if (err instanceof AptosApiError && err.data.error_code === "table_item_not_found") {
      return AccountAddress.fromHexInput(authenticationKey);
    }
    throw err;
  }
}
async function getAccountTokensCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: "0" }
  };
  const graphqlQuery = {
    query: GetAccountTokensCount,
    variables: { where_condition: whereCondition }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountTokensCount"
  });
  if (!data.current_token_ownerships_v2_aggregate.aggregate) {
    throw Error("Failed to get the count of account tokens");
  }
  return data.current_token_ownerships_v2_aggregate.aggregate.count;
}
async function getAccountOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: options == null ? void 0 : options.tokenStandard };
  }
  const graphqlQuery = {
    query: GetAccountOwnedTokens,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedTokens"
  });
  return data.current_token_ownerships_v2;
}
async function getAccountOwnedTokensFromCollectionAddress(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, collectionAddress, options } = args;
  const ownerAddress = AccountAddress.fromHexInput(accountAddress).toString();
  const collAddress = Hex.fromHexInput(collectionAddress).toString();
  const whereCondition = {
    owner_address: { _eq: ownerAddress },
    current_token_data: { collection_id: { _eq: collAddress } },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: options == null ? void 0 : options.tokenStandard };
  }
  const graphqlQuery = {
    query: GetAccountOwnedTokensFromCollection,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedTokensFromCollectionAddress"
  });
  return data.current_token_ownerships_v2;
}
async function getAccountCollectionsWithOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.current_collection = {
      token_standard: { _eq: options == null ? void 0 : options.tokenStandard }
    };
  }
  const graphqlQuery = {
    query: GetAccountCollectionsWithOwnedTokens,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCollectionsWithOwnedTokens"
  });
  return data.current_collection_ownership_v2_view;
}
async function getAccountTransactionsCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const graphqlQuery = {
    query: GetAccountTransactionsCount,
    variables: { address }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountTransactionsCount"
  });
  if (!data.account_transactions_aggregate.aggregate) {
    throw Error("Failed to get the count of account transactions");
  }
  return data.account_transactions_aggregate.aggregate.count;
}
async function getAccountCoinsData(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address }
  };
  const graphqlQuery = {
    query: GetAccountCoinsData,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCoinsData"
  });
  return data.current_fungible_asset_balances;
}
async function getAccountCoinsCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const graphqlQuery = {
    query: GetAccountCoinsCount,
    variables: { address }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCoinsCount"
  });
  if (!data.current_fungible_asset_balances_aggregate.aggregate) {
    throw Error("Failed to get the count of account coins");
  }
  return data.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function getAccountOwnedObjects(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address }
  };
  const graphqlQuery = {
    query: GetAccountOwnedObjects,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedObjects"
  });
  return data.current_objects;
}
async function deriveAccountFromPrivateKey(args) {
  const { aptosConfig, privateKey } = args;
  const publicKey = new AnyPublicKey(privateKey.publicKey());
  if (privateKey instanceof Secp256k1PrivateKey) {
    const authKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 2
      /* SingleKey */
    });
    const address = new AccountAddress({ data: authKey.toUint8Array() });
    return Account.fromPrivateKeyAndAddress({ privateKey, address });
  }
  if (privateKey instanceof Ed25519PrivateKey) {
    const SingleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 2
      /* SingleKey */
    });
    const isSingleSenderTransactionAuthenticator = await isAccountExist({
      authKey: SingleSenderTransactionAuthenticatorAuthKey,
      aptosConfig
    });
    if (isSingleSenderTransactionAuthenticator) {
      const address = new AccountAddress({ data: SingleSenderTransactionAuthenticatorAuthKey.toUint8Array() });
      return Account.fromPrivateKeyAndAddress({ privateKey, address });
    }
    const legacyAuthKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 0
      /* Ed25519 */
    });
    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });
    if (isLegacyEd25519) {
      const address = new AccountAddress({ data: legacyAuthKey.toUint8Array() });
      return Account.fromPrivateKeyAndAddress({ privateKey, address, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${privateKey}`);
}
async function isAccountExist(args) {
  const { aptosConfig, authKey } = args;
  const accountAddress = await lookupOriginalAccountAddress({
    aptosConfig,
    authenticationKey: authKey.toString()
  });
  try {
    await getInfo({
      aptosConfig,
      accountAddress: accountAddress.toString()
    });
    return true;
  } catch (error) {
    if (error.status === 404) {
      return false;
    }
    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);
  }
}
var Account2 = class {
  constructor(config) {
    this.config = config;
  }
  async getAccountInfo(args) {
    return getInfo({ aptosConfig: this.config, ...args });
  }
  async getAccountModules(args) {
    return getModules({ aptosConfig: this.config, ...args });
  }
  async getAccountModule(args) {
    return getModule({ aptosConfig: this.config, ...args });
  }
  async getAccountTransactions(args) {
    return getTransactions({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountResources(args) {
    return getResources({ aptosConfig: this.config, ...args });
  }
  async getAccountResource(args) {
    return getResource({ aptosConfig: this.config, ...args });
  }
  async lookupOriginalAccountAddress(args) {
    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });
  }
  async getAccountTokensCount(args) {
    return getAccountTokensCount({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountOwnedTokens(args) {
    return getAccountOwnedTokens({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountOwnedTokensFromCollectionAddress(args) {
    return getAccountOwnedTokensFromCollectionAddress({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCollectionsWithOwnedTokens(args) {
    return getAccountCollectionsWithOwnedTokens({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountTransactionsCount(args) {
    return getAccountTransactionsCount({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCoinsData(args) {
    return getAccountCoinsData({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCoinsCount(args) {
    return getAccountCoinsCount({ aptosConfig: this.config, ...args });
  }
  async getAccountOwnedObjects(args) {
    return getAccountOwnedObjects({
      aptosConfig: this.config,
      ...args
    });
  }
  async deriveAccountFromPrivateKey(args) {
    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });
  }
};
var AptosConfig = class {
  constructor(settings) {
    var _a, _b, _c;
    this.network = (_a = settings == null ? void 0 : settings.network) != null ? _a : DEFAULT_NETWORK;
    this.fullnode = settings == null ? void 0 : settings.fullnode;
    this.faucet = settings == null ? void 0 : settings.faucet;
    this.indexer = settings == null ? void 0 : settings.indexer;
    this.client = (_b = settings == null ? void 0 : settings.client) != null ? _b : { provider: aptosClient };
    this.clientConfig = (_c = settings == null ? void 0 : settings.clientConfig) != null ? _c : {};
  }
  getRequestUrl(apiType) {
    switch (apiType) {
      case 0:
        if (this.fullnode !== void 0)
          return this.fullnode;
        if (this.network === "custom")
          throw new Error("Please provide a custom full node url");
        return NetworkToNodeAPI[this.network];
      case 2:
        if (this.faucet !== void 0)
          return this.faucet;
        if (this.network === "custom")
          throw new Error("Please provide a custom faucet url");
        return NetworkToFaucetAPI[this.network];
      case 1:
        if (this.indexer !== void 0)
          return this.indexer;
        if (this.network === "custom")
          throw new Error("Please provide a custom indexer url");
        return NetworkToIndexerAPI[this.network];
      default:
        throw Error(`apiType ${apiType} is not supported`);
    }
  }
  isIndexerRequest(url) {
    return NetworkToIndexerAPI[this.network] === url;
  }
};
var AnySignature = class extends Signature {
  constructor(signature) {
    super();
    this.signature = signature;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  toString() {
    return this.signature.toString();
  }
  serialize(serializer) {
    if (this.signature instanceof Ed25519Signature) {
      serializer.serializeU32AsUleb128(
        0
        /* Ed25519 */
      );
      this.signature.serialize(serializer);
    } else if (this.signature instanceof Secp256k1Signature) {
      serializer.serializeU32AsUleb128(
        1
        /* Secp256k1 */
      );
      this.signature.serialize(serializer);
    } else {
      throw new Error("Unknown signature type");
    }
  }
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return new AnySignature(Ed25519Signature.load(deserializer));
      case 1:
        return new AnySignature(Secp256k1Signature.load(deserializer));
      default:
        throw new Error(`Unknown variant index for AnySignature: ${index}`);
    }
  }
};
async function sleep(timeMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeMs);
  });
}
async function getTransactions2(args) {
  const { aptosConfig, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getTransactions",
    path: "transactions",
    params: { start: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
  });
}
async function getGasPriceEstimation(args) {
  const { aptosConfig } = args;
  return memoizeAsync(
    async () => {
      const { data } = await getAptosFullNode({
        aptosConfig,
        originMethod: "getGasPriceEstimation",
        path: "estimate_gas_price"
      });
      return data;
    },
    `gas-price-${aptosConfig.network}`,
    1e3 * 60 * 5
  )();
}
async function getTransactionByVersion(args) {
  const { aptosConfig, ledgerVersion } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getTransactionByVersion",
    path: `transactions/by_version/${ledgerVersion}`
  });
  return data;
}
async function getTransactionByHash(args) {
  const { aptosConfig, transactionHash } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    path: `transactions/by_hash/${transactionHash}`,
    originMethod: "getTransactionByHash"
  });
  return data;
}
async function isTransactionPending(args) {
  const { aptosConfig, transactionHash } = args;
  try {
    const transaction = await getTransactionByHash({ aptosConfig, transactionHash });
    return transaction.type === "pending_transaction";
  } catch (e) {
    if ((e == null ? void 0 : e.status) === 404) {
      return true;
    }
    throw e;
  }
}
async function waitForTransaction(args) {
  var _a, _b, _c;
  const { aptosConfig, transactionHash, options } = args;
  const timeoutSecs = (_a = options == null ? void 0 : options.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;
  const checkSuccess = (_b = options == null ? void 0 : options.checkSuccess) != null ? _b : true;
  const indexerVersionCheck = (_c = options == null ? void 0 : options.indexerVersionCheck) != null ? _c : true;
  let isPending = true;
  let timeElapsed = 0;
  let lastTxn;
  let lastError;
  let backoffIntervalMs = 200;
  const backoffMultiplier = 1.5;
  while (isPending) {
    if (timeElapsed >= timeoutSecs) {
      break;
    }
    try {
      lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });
      isPending = lastTxn.type === "pending_transaction";
      if (!isPending) {
        break;
      }
    } catch (e) {
      const isAptosApiError = e instanceof AptosApiError;
      if (!isAptosApiError) {
        throw e;
      }
      lastError = e;
      const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;
      if (isRequestError) {
        throw e;
      }
    }
    await sleep(backoffIntervalMs);
    timeElapsed += backoffIntervalMs / 1e3;
    backoffIntervalMs *= backoffMultiplier;
  }
  if (lastTxn === void 0) {
    if (lastError) {
      throw lastError;
    } else {
      throw new WaitForTransactionError(
        `Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`,
        lastTxn
      );
    }
  }
  if (lastTxn.type === "pending_transaction") {
    throw new WaitForTransactionError(
      `Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`,
      lastTxn
    );
  }
  if (!checkSuccess) {
    return lastTxn;
  }
  if (!lastTxn.success) {
    throw new FailedTransactionError(
      `Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`,
      lastTxn
    );
  }
  if (indexerVersionCheck) {
    try {
      await waitForLastSuccessIndexerVersionSync({ aptosConfig, ledgerVersion: Number(lastTxn.version) });
    } catch (_e) {
      throw new WaitForTransactionError(
        `Transaction ${transactionHash} committed, but timed out waiting for indexer to sync with ledger version ${lastTxn.version}.You can disable this check by setting \`indexerVersionCheck\` to false in the \`extraArgs\` parameter.`,
        lastTxn
      );
    }
  }
  return lastTxn;
}
async function waitForLastSuccessIndexerVersionSync(args) {
  const { aptosConfig, ledgerVersion } = args;
  const timeoutMilliseconds = 3e3;
  const startTime = (/* @__PURE__ */ new Date()).getTime();
  let indexerVersion = -1;
  while (indexerVersion < ledgerVersion) {
    if ((/* @__PURE__ */ new Date()).getTime() - startTime > timeoutMilliseconds) {
      throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    }
    indexerVersion = await getIndexerLastSuccessVersion({ aptosConfig });
    if (indexerVersion >= ledgerVersion) {
      break;
    }
    await sleep(200);
  }
}
var WaitForTransactionError = class extends Error {
  constructor(message, lastSubmittedTransaction) {
    super(message);
    this.lastSubmittedTransaction = lastSubmittedTransaction;
  }
};
var FailedTransactionError = class extends Error {
  constructor(message, transaction) {
    super(message);
    this.transaction = transaction;
  }
};
var AccountAuthenticator = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return AccountAuthenticatorEd25519.load(deserializer);
      case 1:
        return AccountAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return AccountAuthenticatorSingleKey.load(deserializer);
      case 3:
        return AccountAuthenticatorMultiKey.load(deserializer);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);
    }
  }
};
var AccountAuthenticatorEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Ed25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorEd25519(public_key, signature);
  }
};
var AccountAuthenticatorMultiEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* MultiEd25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorMultiEd25519(public_key, signature);
  }
};
var AccountAuthenticatorSingleKey = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* SingleKey */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = AnyPublicKey.deserialize(deserializer);
    const signature = AnySignature.deserialize(deserializer);
    return new AccountAuthenticatorSingleKey(public_key, signature);
  }
};
var AccountAuthenticatorMultiKey = class extends AccountAuthenticator {
  constructor(public_keys, signatures, signatures_bitmap) {
    super();
    this.public_keys = public_keys;
    this.signatures = signatures;
    this.signatures_bitmap = signatures_bitmap;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* MultiKey */
    );
    this.public_keys.serialize(serializer);
    serializer.serializeVector(this.signatures);
    serializer.serializeBytes(this.signatures_bitmap);
  }
  static load(deserializer) {
    const public_keys = MultiKey.deserialize(deserializer);
    const signatures = deserializer.deserializeVector(AnySignature);
    const signatures_bitmap = deserializer.deserializeBytes();
    return new AccountAuthenticatorMultiKey(public_keys, signatures, signatures_bitmap);
  }
};
var TransactionAuthenticator = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionAuthenticatorEd25519.load(deserializer);
      case 1:
        return TransactionAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return TransactionAuthenticatorMultiAgent.load(deserializer);
      case 3:
        return TransactionAuthenticatorFeePayer.load(deserializer);
      case 4:
        return TransactionAuthenticatorSingleSender.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);
    }
  }
};
var TransactionAuthenticatorEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Ed25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* MultiEd25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorMultiEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiAgent = class extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* MultiAgent */
    );
    this.sender.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    serializer.serializeVector(this.secondary_signers);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);
    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);
    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);
  }
};
var TransactionAuthenticatorFeePayer = class extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
    this.fee_payer = fee_payer;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* FeePayer */
    );
    this.sender.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    serializer.serializeVector(this.secondary_signers);
    this.fee_payer.address.serialize(serializer);
    this.fee_payer.authenticator.serialize(serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);
    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);
    const address = AccountAddress.deserialize(deserializer);
    const authenticator = AccountAuthenticator.deserialize(deserializer);
    const fee_payer = { address, authenticator };
    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);
  }
};
var TransactionAuthenticatorSingleSender = class extends TransactionAuthenticator {
  constructor(sender) {
    super();
    this.sender = sender;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      4
      /* SingleSender */
    );
    this.sender.serialize(serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    return new TransactionAuthenticatorSingleSender(sender);
  }
};
var ChainId = class extends Serializable {
  constructor(chainId) {
    super();
    this.chainId = chainId;
  }
  serialize(serializer) {
    serializer.serializeU8(this.chainId);
  }
  static deserialize(deserializer) {
    const chainId = deserializer.deserializeU8();
    return new ChainId(chainId);
  }
};
var Identifier = class extends Serializable {
  constructor(identifier) {
    super();
    this.identifier = identifier;
  }
  serialize(serializer) {
    serializer.serializeStr(this.identifier);
  }
  static deserialize(deserializer) {
    const identifier = deserializer.deserializeStr();
    return new Identifier(identifier);
  }
};
var ModuleId = class extends Serializable {
  constructor(address, name) {
    super();
    this.address = address;
    this.name = name;
  }
  static fromStr(moduleId) {
    const parts = moduleId.split("::");
    if (parts.length !== 2) {
      throw new Error("Invalid module id.");
    }
    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.name.serialize(serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    return new ModuleId(address, name);
  }
};
var TypeTag = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TypeTagBool.load(deserializer);
      case 1:
        return TypeTagU8.load(deserializer);
      case 2:
        return TypeTagU64.load(deserializer);
      case 3:
        return TypeTagU128.load(deserializer);
      case 4:
        return TypeTagAddress.load(deserializer);
      case 5:
        return TypeTagSigner.load(deserializer);
      case 6:
        return TypeTagVector.load(deserializer);
      case 7:
        return TypeTagStruct.load(deserializer);
      case 8:
        return TypeTagU16.load(deserializer);
      case 9:
        return TypeTagU32.load(deserializer);
      case 10:
        return TypeTagU256.load(deserializer);
      case 255:
        return TypeTagGeneric.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${index}`);
    }
  }
  isBool() {
    return this instanceof TypeTagBool;
  }
  isAddress() {
    return this instanceof TypeTagAddress;
  }
  isGeneric() {
    return this instanceof TypeTagGeneric;
  }
  isSigner() {
    return this instanceof TypeTagSigner;
  }
  isVector() {
    return this instanceof TypeTagVector;
  }
  isStruct() {
    return this instanceof TypeTagStruct;
  }
  isU8() {
    return this instanceof TypeTagU8;
  }
  isU16() {
    return this instanceof TypeTagU16;
  }
  isU32() {
    return this instanceof TypeTagU32;
  }
  isU64() {
    return this instanceof TypeTagU64;
  }
  isU128() {
    return this instanceof TypeTagU128;
  }
  isU256() {
    return this instanceof TypeTagU256;
  }
};
var TypeTagBool = class extends TypeTag {
  toString() {
    return "bool";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Bool */
    );
  }
  static load(_deserializer) {
    return new TypeTagBool();
  }
};
var TypeTagU8 = class extends TypeTag {
  toString() {
    return "u8";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* U8 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU8();
  }
};
var TypeTagU16 = class extends TypeTag {
  toString() {
    return "u16";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      8
      /* U16 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU16();
  }
};
var TypeTagU32 = class extends TypeTag {
  toString() {
    return "u32";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      9
      /* U32 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU32();
  }
};
var TypeTagU64 = class extends TypeTag {
  toString() {
    return "u64";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* U64 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU64();
  }
};
var TypeTagU128 = class extends TypeTag {
  toString() {
    return "u128";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* U128 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU128();
  }
};
var TypeTagU256 = class extends TypeTag {
  toString() {
    return "u256";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      10
      /* U256 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU256();
  }
};
var TypeTagAddress = class extends TypeTag {
  toString() {
    return "address";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      4
      /* Address */
    );
  }
  static load(_deserializer) {
    return new TypeTagAddress();
  }
};
var TypeTagSigner = class extends TypeTag {
  toString() {
    return "signer";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      5
      /* Signer */
    );
  }
  static load(_deserializer) {
    return new TypeTagSigner();
  }
};
var TypeTagReference = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      254
      /* Reference */
    );
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new TypeTagReference(value);
  }
};
var TypeTagGeneric = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      255
      /* Generic */
    );
    serializer.serializeU32(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU32();
    return new TypeTagGeneric(value);
  }
};
var TypeTagVector = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      6
      /* Vector */
    );
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new TypeTagVector(value);
  }
};
var TypeTagStruct = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    let typePredicate = "";
    if (this.value.type_args.length > 0) {
      typePredicate = `<${this.value.type_args.map((typeArg) => typeArg.toString()).join(", ")}>`;
    }
    return `${this.value.address.toString()}::${this.value.module_name.identifier}::${this.value.name.identifier}${typePredicate}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      7
      /* Struct */
    );
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = StructTag.deserialize(deserializer);
    return new TypeTagStruct(value);
  }
  isTypeTag(address, moduleName, structName) {
    return this.value.module_name.identifier === moduleName && this.value.name.identifier === structName && this.value.address.equals(address);
  }
  isString() {
    return this.isTypeTag(AccountAddress.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(AccountAddress.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(AccountAddress.ONE, "object", "Object");
  }
};
var StructTag = class extends Serializable {
  constructor(address, module_name, name, type_args) {
    super();
    this.address = address;
    this.module_name = module_name;
    this.name = name;
    this.type_args = type_args;
  }
  serialize(serializer) {
    serializer.serialize(this.address);
    serializer.serialize(this.module_name);
    serializer.serialize(this.name);
    serializer.serializeVector(this.type_args);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const moduleName = Identifier.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    const typeArgs = deserializer.deserializeVector(TypeTag);
    return new StructTag(address, moduleName, name, typeArgs);
  }
};
function deserializeFromScriptArgument(deserializer) {
  const index = deserializer.deserializeUleb128AsU32();
  switch (index) {
    case 0:
      return U8.deserialize(deserializer);
    case 1:
      return U64.deserialize(deserializer);
    case 2:
      return U128.deserialize(deserializer);
    case 3:
      return AccountAddress.deserialize(deserializer);
    case 4:
      return MoveVector.deserialize(deserializer, U8);
    case 5:
      return Bool.deserialize(deserializer);
    case 6:
      return U16.deserialize(deserializer);
    case 7:
      return U32.deserialize(deserializer);
    case 8:
      return U256.deserialize(deserializer);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);
  }
}
var TransactionPayload = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionPayloadScript.load(deserializer);
      case 2:
        return TransactionPayloadEntryFunction.load(deserializer);
      case 3:
        return TransactionPayloadMultisig.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
    }
  }
};
var TransactionPayloadScript = class extends TransactionPayload {
  constructor(script) {
    super();
    this.script = script;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Script */
    );
    this.script.serialize(serializer);
  }
  static load(deserializer) {
    const script = Script.deserialize(deserializer);
    return new TransactionPayloadScript(script);
  }
};
var TransactionPayloadEntryFunction = class extends TransactionPayload {
  constructor(entryFunction) {
    super();
    this.entryFunction = entryFunction;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* EntryFunction */
    );
    this.entryFunction.serialize(serializer);
  }
  static load(deserializer) {
    const entryFunction = EntryFunction.deserialize(deserializer);
    return new TransactionPayloadEntryFunction(entryFunction);
  }
};
var TransactionPayloadMultisig = class extends TransactionPayload {
  constructor(multiSig) {
    super();
    this.multiSig = multiSig;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* Multisig */
    );
    this.multiSig.serialize(serializer);
  }
  static load(deserializer) {
    const multiSig = MultiSig.deserialize(deserializer);
    return new TransactionPayloadMultisig(multiSig);
  }
};
var EntryFunction = class {
  constructor(module_name, function_name, type_args, args) {
    this.module_name = module_name;
    this.function_name = function_name;
    this.type_args = type_args;
    this.args = args;
  }
  static build(module_id, function_name, type_args, args) {
    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);
  }
  serialize(serializer) {
    this.module_name.serialize(serializer);
    this.function_name.serialize(serializer);
    serializer.serializeVector(this.type_args);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      item.serializeForEntryFunction(serializer);
    });
  }
  static deserialize(deserializer) {
    const module_name = ModuleId.deserialize(deserializer);
    const function_name = Identifier.deserialize(deserializer);
    const type_args = deserializer.deserializeVector(TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const args = new Array();
    for (let i = 0; i < length; i += 1) {
      const fixedBytesLength = deserializer.deserializeUleb128AsU32();
      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);
      args.push(fixedBytes);
    }
    return new EntryFunction(module_name, function_name, type_args, args);
  }
};
var Script = class {
  constructor(bytecode, type_args, args) {
    this.bytecode = bytecode;
    this.type_args = type_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.bytecode);
    serializer.serializeVector(this.type_args);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      item.serializeForScriptFunction(serializer);
    });
  }
  static deserialize(deserializer) {
    const bytecode = deserializer.deserializeBytes();
    const type_args = deserializer.deserializeVector(TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const args = new Array();
    for (let i = 0; i < length; i += 1) {
      const scriptArgument = deserializeFromScriptArgument(deserializer);
      args.push(scriptArgument);
    }
    return new Script(bytecode, type_args, args);
  }
};
var MultiSig = class {
  constructor(multisig_address, transaction_payload) {
    this.multisig_address = multisig_address;
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    this.multisig_address.serialize(serializer);
    if (this.transaction_payload === void 0) {
      serializer.serializeBool(false);
    } else {
      serializer.serializeBool(true);
      this.transaction_payload.serialize(serializer);
    }
  }
  static deserialize(deserializer) {
    const multisig_address = AccountAddress.deserialize(deserializer);
    const payloadPresent = deserializer.deserializeBool();
    let transaction_payload;
    if (payloadPresent) {
      transaction_payload = MultisigTransactionPayload.deserialize(deserializer);
    }
    return new MultiSig(multisig_address, transaction_payload);
  }
};
var MultisigTransactionPayload = class {
  constructor(transaction_payload) {
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.transaction_payload.serialize(serializer);
  }
  static deserialize(deserializer) {
    deserializer.deserializeUleb128AsU32();
    return new MultisigTransactionPayload(EntryFunction.deserialize(deserializer));
  }
};
var RawTransaction = class extends Serializable {
  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {
    super();
    this.sender = sender;
    this.sequence_number = sequence_number;
    this.payload = payload;
    this.max_gas_amount = max_gas_amount;
    this.gas_unit_price = gas_unit_price;
    this.expiration_timestamp_secs = expiration_timestamp_secs;
    this.chain_id = chain_id;
  }
  serialize(serializer) {
    this.sender.serialize(serializer);
    serializer.serializeU64(this.sequence_number);
    this.payload.serialize(serializer);
    serializer.serializeU64(this.max_gas_amount);
    serializer.serializeU64(this.gas_unit_price);
    serializer.serializeU64(this.expiration_timestamp_secs);
    this.chain_id.serialize(serializer);
  }
  static deserialize(deserializer) {
    const sender = AccountAddress.deserialize(deserializer);
    const sequence_number = deserializer.deserializeU64();
    const payload = TransactionPayload.deserialize(deserializer);
    const max_gas_amount = deserializer.deserializeU64();
    const gas_unit_price = deserializer.deserializeU64();
    const expiration_timestamp_secs = deserializer.deserializeU64();
    const chain_id = ChainId.deserialize(deserializer);
    return new RawTransaction(
      sender,
      sequence_number,
      payload,
      max_gas_amount,
      gas_unit_price,
      expiration_timestamp_secs,
      chain_id
    );
  }
};
var RawTransactionWithData = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return MultiAgentRawTransaction.load(deserializer);
      case 1:
        return FeePayerRawTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);
    }
  }
};
var MultiAgentRawTransaction = class extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* MultiAgentTransaction */
    );
    this.raw_txn.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);
    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);
  }
};
var FeePayerRawTransaction = class extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.fee_payer_address = fee_payer_address;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* FeePayerTransaction */
    );
    this.raw_txn.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    this.fee_payer_address.serialize(serializer);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);
    const feePayerAddress = AccountAddress.deserialize(deserializer);
    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);
  }
};
var SignedTransaction = class extends Serializable {
  constructor(raw_txn, authenticator) {
    super();
    this.raw_txn = raw_txn;
    this.authenticator = authenticator;
  }
  serialize(serializer) {
    this.raw_txn.serialize(serializer);
    this.authenticator.serialize(serializer);
  }
  static deserialize(deserializer) {
    const raw_txn = RawTransaction.deserialize(deserializer);
    const authenticator = TransactionAuthenticator.deserialize(deserializer);
    return new SignedTransaction(raw_txn, authenticator);
  }
};
function isValidIdentifier(str) {
  return !!str.match(/^[_a-zA-Z0-9]+$/);
}
function isValidWhitespaceCharacter(char) {
  return !!char.match(/\s/);
}
function consumeWhitespace(tagStr, pos) {
  let i = pos;
  for (; i < tagStr.length; i += 1) {
    const innerChar = tagStr[i];
    if (!isValidWhitespaceCharacter(innerChar)) {
      break;
    }
  }
  return i;
}
var TypeTagParserErrorType = ((TypeTagParserErrorType2) => {
  TypeTagParserErrorType2["InvalidTypeTag"] = "unknown type";
  TypeTagParserErrorType2["UnexpectedTypeArgumentClose"] = "unexpected '>'";
  TypeTagParserErrorType2["UnexpectedWhitespaceCharacter"] = "unexpected whitespace character";
  TypeTagParserErrorType2["UnexpectedComma"] = "unexpected ','";
  TypeTagParserErrorType2["TypeArgumentCountMismatch"] = "type argument count doesn't match expected amount";
  TypeTagParserErrorType2["MissingTypeArgumentClose"] = "no matching '>' for '<'";
  TypeTagParserErrorType2["UnexpectedPrimitiveTypeArguments"] = "primitive types not expected to have type arguments";
  TypeTagParserErrorType2["UnexpectedVectorTypeArgumentCount"] = "vector type expected to have exactly one type argument";
  TypeTagParserErrorType2["UnexpectedStructFormat"] = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name";
  TypeTagParserErrorType2["InvalidModuleNameCharacter"] = "module name must only contain alphanumeric or '_' characters";
  TypeTagParserErrorType2["InvalidStructNameCharacter"] = "struct name must only contain alphanumeric or '_' characters";
  return TypeTagParserErrorType2;
})(TypeTagParserErrorType || {});
var TypeTagParserError = class extends Error {
  constructor(typeTagStr, invalidReason) {
    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);
  }
};
function parseTypeTag(typeStr, options) {
  var _a;
  const allowGenerics = (_a = options == null ? void 0 : options.allowGenerics) != null ? _a : false;
  const saved = [];
  let innerTypes = [];
  let curTypes = [];
  let cur = 0;
  let currentStr = "";
  let expectedTypes = 1;
  while (cur < typeStr.length) {
    const char = typeStr[cur];
    if (char === "<") {
      saved.push({
        savedExpectedTypes: expectedTypes,
        savedStr: currentStr,
        savedTypes: curTypes
      });
      currentStr = "";
      curTypes = [];
      expectedTypes = 1;
    } else if (char === ">") {
      if (currentStr !== "") {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        curTypes.push(newType);
      }
      const savedPop = saved.pop();
      if (savedPop === void 0) {
        throw new TypeTagParserError(
          typeStr,
          "unexpected '>'"
          /* UnexpectedTypeArgumentClose */
        );
      }
      if (expectedTypes !== curTypes.length) {
        throw new TypeTagParserError(
          typeStr,
          "type argument count doesn't match expected amount"
          /* TypeArgumentCountMismatch */
        );
      }
      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;
      innerTypes = curTypes;
      curTypes = savedTypes;
      currentStr = savedStr;
      expectedTypes = savedExpectedTypes;
    } else if (char === ",") {
      if (currentStr.length !== 0) {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        innerTypes = [];
        curTypes.push(newType);
        currentStr = "";
        expectedTypes += 1;
      }
    } else if (isValidWhitespaceCharacter(char)) {
      let parsedTypeTag = false;
      if (currentStr.length !== 0) {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        innerTypes = [];
        curTypes.push(newType);
        currentStr = "";
        parsedTypeTag = true;
      }
      cur = consumeWhitespace(typeStr, cur);
      const nextChar = typeStr[cur];
      if (cur < typeStr.length && parsedTypeTag && nextChar !== "," && nextChar !== ">") {
        throw new TypeTagParserError(
          typeStr,
          "unexpected whitespace character"
          /* UnexpectedWhitespaceCharacter */
        );
      }
      continue;
    } else {
      currentStr += char;
    }
    cur += 1;
  }
  if (saved.length > 0) {
    throw new TypeTagParserError(
      typeStr,
      "no matching '>' for '<'"
      /* MissingTypeArgumentClose */
    );
  }
  switch (curTypes.length) {
    case 0:
      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);
    case 1:
      if (currentStr === "") {
        return curTypes[0];
      }
      throw new TypeTagParserError(
        typeStr,
        "unexpected ','"
        /* UnexpectedComma */
      );
    default:
      throw new TypeTagParserError(
        typeStr,
        "unexpected whitespace character"
        /* UnexpectedWhitespaceCharacter */
      );
  }
}
function parseTypeTagInner(str, types, allowGenerics) {
  switch (str) {
    case "&signer":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagReference(new TypeTagSigner());
    case "signer":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagSigner();
    case "bool":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagBool();
    case "address":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagAddress();
    case "u8":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU8();
    case "u16":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU16();
    case "u32":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU32();
    case "u64":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU64();
    case "u128":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU128();
    case "u256":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU256();
    case "vector":
      if (types.length !== 1) {
        throw new TypeTagParserError(
          str,
          "vector type expected to have exactly one type argument"
          /* UnexpectedVectorTypeArgumentCount */
        );
      }
      return new TypeTagVector(types[0]);
    default:
      if (allowGenerics && str.match(/^T[0-9]+$/)) {
        return new TypeTagGeneric(Number(str.split("T")[1]));
      }
      if (!str.match(/.*:.*/)) {
        throw new TypeTagParserError(
          str,
          "unknown type"
          /* InvalidTypeTag */
        );
      }
      const structParts = str.split("::");
      if (structParts.length !== 3) {
        throw new TypeTagParserError(
          str,
          "unexpected struct format, must be of the form 0xaddress::module_name::struct_name"
          /* UnexpectedStructFormat */
        );
      }
      if (!isValidIdentifier(structParts[1])) {
        throw new TypeTagParserError(
          str,
          "module name must only contain alphanumeric or '_' characters"
          /* InvalidModuleNameCharacter */
        );
      }
      if (!isValidIdentifier(structParts[2])) {
        throw new TypeTagParserError(
          str,
          "struct name must only contain alphanumeric or '_' characters"
          /* InvalidStructNameCharacter */
        );
      }
      return new TypeTagStruct(
        new StructTag(
          AccountAddress.fromString(structParts[0]),
          new Identifier(structParts[1]),
          new Identifier(structParts[2]),
          types
        )
      );
  }
}
function isBool(arg) {
  return typeof arg === "boolean";
}
function isString(arg) {
  return typeof arg === "string";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isLargeNumber(arg) {
  return typeof arg === "number" || typeof arg === "bigint" || typeof arg === "string";
}
function isNull(arg) {
  return arg === null || arg === void 0;
}
function isBcsBool(arg) {
  return arg instanceof Bool;
}
function isBcsAddress(arg) {
  return arg instanceof AccountAddress;
}
function isBcsString(arg) {
  return arg instanceof MoveString;
}
function isBcsFixedBytes(arg) {
  return arg instanceof FixedBytes;
}
function isBcsU8(arg) {
  return arg instanceof U8;
}
function isBcsU16(arg) {
  return arg instanceof U16;
}
function isBcsU32(arg) {
  return arg instanceof U32;
}
function isBcsU64(arg) {
  return arg instanceof U64;
}
function isBcsU128(arg) {
  return arg instanceof U128;
}
function isBcsU256(arg) {
  return arg instanceof U256;
}
function isScriptDataInput(arg) {
  return "bytecode" in arg;
}
function throwTypeMismatch(expectedType, position) {
  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);
}
function findFirstNonSignerArg(functionAbi) {
  return functionAbi.params.findIndex((param) => param !== "signer" && param !== "&signer");
}
function getFunctionParts(functionArg) {
  const funcNameParts = functionArg.split("::");
  if (funcNameParts.length !== 3) {
    throw new Error(`Invalid function ${functionArg}`);
  }
  const moduleAddress = funcNameParts[0];
  const moduleName = funcNameParts[1];
  const functionName = funcNameParts[2];
  return { moduleAddress, moduleName, functionName };
}
function standardizeTypeTags(typeArguments) {
  var _a;
  return (_a = typeArguments == null ? void 0 : typeArguments.map((typeArg) => {
    if (isString(typeArg)) {
      return parseTypeTag(typeArg);
    }
    return typeArg;
  })) != null ? _a : [];
}
async function fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig) {
  var _a;
  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });
  const functionAbi = (_a = module.abi) == null ? void 0 : _a.exposed_functions.find((func) => func.name === functionName);
  if (!functionAbi) {
    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);
  }
  if (!functionAbi.is_entry) {
    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);
  }
  const first = findFirstNonSignerArg(functionAbi);
  const params = [];
  for (let i = first; i < functionAbi.params.length; i += 1) {
    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));
  }
  return {
    typeParameters: functionAbi.generic_type_params,
    parameters: params
  };
}
function convertArgument(functionName, functionAbi, arg, position, genericTypeParams) {
  if (position >= functionAbi.parameters.length) {
    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);
  }
  if (isBcsBool(arg) || isBcsU8(arg) || isBcsU16(arg) || isBcsU32(arg) || isBcsU64(arg) || isBcsU128(arg) || isBcsU256(arg) || isBcsAddress(arg) || isBcsString(arg) || isBcsFixedBytes(arg) || arg instanceof MoveVector || arg instanceof MoveOption) {
    checkType(functionAbi, arg, position);
    return arg;
  }
  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);
}
function parseArg(arg, param, position, genericTypeParams) {
  if (param.isBool()) {
    if (isBool(arg)) {
      return new Bool(arg);
    }
    throwTypeMismatch("boolean", position);
  }
  if (param.isAddress()) {
    if (isString(arg)) {
      return AccountAddress.fromString(arg);
    }
    throwTypeMismatch("string", position);
  }
  if (param.isU8()) {
    if (isNumber(arg)) {
      return new U8(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU16()) {
    if (isNumber(arg)) {
      return new U16(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU32()) {
    if (isNumber(arg)) {
      return new U32(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU64()) {
    if (isLargeNumber(arg)) {
      return new U64(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isU128()) {
    if (isLargeNumber(arg)) {
      return new U128(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isU256()) {
    if (isLargeNumber(arg)) {
      return new U256(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isGeneric()) {
    const genericIndex = param.value;
    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {
      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);
    }
    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);
  }
  if (param.isVector()) {
    if (param.value.isU8() && isString(arg)) {
      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());
    }
    if (Array.isArray(arg)) {
      return new MoveVector(arg.map((item) => parseArg(item, param.value, position, genericTypeParams)));
    }
    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
  }
  if (param.isStruct()) {
    if (param.isString()) {
      if (isString(arg)) {
        return new MoveString(arg);
      }
      throwTypeMismatch("string", position);
    }
    if (param.isObject()) {
      if (isString(arg)) {
        return AccountAddress.fromString(arg);
      }
      throwTypeMismatch("string", position);
    }
    if (param.isOption()) {
      if (isNull(arg)) {
        return new MoveOption(null);
      }
      return new MoveOption(parseArg(arg, param.value.type_args[0], position, genericTypeParams));
    }
    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
}
function checkType(functionAbi, arg, position) {
  const param = functionAbi.parameters[position];
  if (param.isBool()) {
    if (isBcsBool(arg)) {
      return;
    }
    throwTypeMismatch("Bool", position);
  }
  if (param.isAddress()) {
    if (isBcsAddress(arg)) {
      return;
    }
    throwTypeMismatch("AccountAddress", position);
  }
  if (param.isU8()) {
    if (isBcsU8(arg)) {
      return;
    }
    throwTypeMismatch("U8", position);
  }
  if (param.isU16()) {
    if (isBcsU16(arg)) {
      return;
    }
    throwTypeMismatch("U16", position);
  }
  if (param.isU32()) {
    if (isBcsU32(arg)) {
      return;
    }
    throwTypeMismatch("U32", position);
  }
  if (param.isU64()) {
    if (isBcsU64(arg)) {
      return;
    }
    throwTypeMismatch("U64", position);
  }
  if (param.isU128()) {
    if (isBcsU128(arg)) {
      return;
    }
    throwTypeMismatch("U128", position);
  }
  if (param.isU256()) {
    if (isBcsU256(arg)) {
      return;
    }
    throwTypeMismatch("U256", position);
  }
  if (param.isVector()) {
    if (arg instanceof MoveVector) {
      return;
    }
    throwTypeMismatch("MoveVector", position);
  }
  if (param instanceof TypeTagStruct) {
    if (param.isString()) {
      if (isBcsString(arg)) {
        return;
      }
      throwTypeMismatch("MoveString", position);
    }
    if (param.isObject()) {
      if (isBcsAddress(arg)) {
        return;
      }
      throwTypeMismatch("AccountAddress", position);
    }
    if (param.isOption()) {
      if (arg instanceof MoveOption) {
        return;
      }
      throwTypeMismatch("MoveOption", position);
    }
  }
  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);
}
async function generateTransactionPayload(args) {
  if (isScriptDataInput(args)) {
    return generateTransactionPayloadScript(args);
  }
  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);
  const functionAbi = await memoizeAsync(
    async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig),
    `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,
    1e3 * 60 * 5
  )();
  return generateTransactionPayloadWithABI(args, functionAbi);
}
function generateTransactionPayloadWithABI(args, functionAbi) {
  if (isScriptDataInput(args)) {
    return generateTransactionPayloadScript(args);
  }
  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);
  const typeArguments = standardizeTypeTags(args.typeArguments);
  if (typeArguments.length !== functionAbi.typeParameters.length) {
    throw new Error(
      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`
    );
  }
  const functionArguments = args.functionArguments.map(
    (arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)
  );
  if (functionArguments.length !== functionAbi.parameters.length) {
    throw new Error(
      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`
    );
  }
  const entryFunctionPayload = EntryFunction.build(
    `${moduleAddress}::${moduleName}`,
    functionName,
    typeArguments,
    functionArguments
  );
  if ("multisigAddress" in args) {
    let multisigAddress;
    if (typeof args.multisigAddress === "string") {
      multisigAddress = AccountAddress.fromString(args.multisigAddress);
    } else {
      multisigAddress = args.multisigAddress;
    }
    return new TransactionPayloadMultisig(
      new MultiSig(multisigAddress, new MultisigTransactionPayload(entryFunctionPayload))
    );
  }
  return new TransactionPayloadEntryFunction(entryFunctionPayload);
}
function generateTransactionPayloadScript(args) {
  var _a;
  return new TransactionPayloadScript(
    new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), (_a = args.typeArguments) != null ? _a : [], args.functionArguments)
  );
}
async function generateRawTransaction(args) {
  const { aptosConfig, sender, payload, options } = args;
  const getSequenceNumber = (options == null ? void 0 : options.accountSequenceNumber) ? Promise.resolve({ sequence_number: options.accountSequenceNumber }) : getInfo({ aptosConfig, accountAddress: sender });
  const getChainId = NetworkToChainId[aptosConfig.network] ? Promise.resolve({ chain_id: NetworkToChainId[aptosConfig.network] }) : getLedgerInfo({ aptosConfig });
  const getGasUnitPrice = (options == null ? void 0 : options.gasUnitPrice) ? Promise.resolve({ gas_estimate: options.gasUnitPrice }) : getGasPriceEstimation({ aptosConfig });
  const [{ sequence_number: sequenceNumber }, { chain_id: chainId }, { gas_estimate: gasEstimate }] = await Promise.all(
    [getSequenceNumber, getChainId, getGasUnitPrice]
  );
  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {
    maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
    gasUnitPrice: BigInt(gasEstimate),
    expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),
    ...options
  };
  return new RawTransaction(
    AccountAddress.fromHexInput(sender),
    BigInt(sequenceNumber),
    payload,
    BigInt(maxGasAmount),
    BigInt(gasUnitPrice),
    BigInt(expireTimestamp),
    new ChainId(chainId)
  );
}
async function buildTransaction(args) {
  const { aptosConfig, sender, payload, options, secondarySignerAddresses, feePayerAddress } = args;
  const rawTxn = await generateRawTransaction({
    aptosConfig,
    sender,
    payload,
    options
  });
  if (feePayerAddress) {
    const signers = secondarySignerAddresses ? secondarySignerAddresses.map((signer) => AccountAddress.fromHexInput(signer)) : [];
    return {
      rawTransaction: rawTxn.bcsToBytes(),
      secondarySignerAddresses: signers,
      feePayerAddress: AccountAddress.fromHexInput(feePayerAddress)
    };
  }
  if (secondarySignerAddresses) {
    const signers = secondarySignerAddresses.map(
      (signer) => AccountAddress.fromHexInput(signer)
    );
    return {
      rawTransaction: rawTxn.bcsToBytes(),
      secondarySignerAddresses: signers
    };
  }
  return { rawTransaction: rawTxn.bcsToBytes() };
}
function generateSignedTransactionForSimulation(args) {
  var _a, _b;
  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;
  const deserializer = new Deserializer(transaction.rawTransaction);
  const deserializedTransaction = RawTransaction.deserialize(deserializer);
  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);
  if (transaction.feePayerAddress) {
    const transactionToSign = new FeePayerRawTransaction(
      deserializedTransaction,
      (_a = transaction.secondarySignerAddresses) != null ? _a : [],
      transaction.feePayerAddress
    );
    let secondaryAccountAuthenticators = [];
    if (secondarySignersPublicKeys) {
      secondaryAccountAuthenticators = secondarySignersPublicKeys.map(
        (publicKey) => getAuthenticatorForSimulation(publicKey)
      );
    }
    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);
    const transactionAuthenticator2 = new TransactionAuthenticatorFeePayer(
      accountAuthenticator,
      (_b = transaction.secondarySignerAddresses) != null ? _b : [],
      secondaryAccountAuthenticators,
      {
        address: transaction.feePayerAddress,
        authenticator: feePayerAuthenticator
      }
    );
    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();
  }
  if (transaction.secondarySignerAddresses) {
    const transactionToSign = new MultiAgentRawTransaction(
      deserializedTransaction,
      transaction.secondarySignerAddresses
    );
    let secondaryAccountAuthenticators = [];
    secondaryAccountAuthenticators = secondarySignersPublicKeys.map(
      (publicKey) => getAuthenticatorForSimulation(publicKey)
    );
    const transactionAuthenticator2 = new TransactionAuthenticatorMultiAgent(
      accountAuthenticator,
      transaction.secondarySignerAddresses,
      secondaryAccountAuthenticators
    );
    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();
  }
  let transactionAuthenticator;
  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {
    transactionAuthenticator = new TransactionAuthenticatorEd25519(
      accountAuthenticator.public_key,
      accountAuthenticator.signature
    );
  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {
    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);
  } else {
    throw new Error("Invalid public key");
  }
  return new SignedTransaction(deserializedTransaction, transactionAuthenticator).bcsToBytes();
}
function getAuthenticatorForSimulation(publicKey) {
  if (publicKey instanceof AnyPublicKey) {
    if (publicKey.publicKey instanceof Ed25519PublicKey) {
      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));
    }
    if (publicKey.publicKey instanceof Secp256k1PublicKey) {
      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));
    }
  }
  return new AccountAuthenticatorEd25519(
    new Ed25519PublicKey(publicKey.toUint8Array()),
    new Ed25519Signature(new Uint8Array(64))
  );
}
function sign(args) {
  const { signer, transaction } = args;
  const transactionToSign = deriveTransactionType(transaction);
  const message = getSigningMessage(transactionToSign);
  const signerSignature = signer.sign(message);
  switch (signer.signingScheme) {
    case 0:
      return new AccountAuthenticatorEd25519(
        new Ed25519PublicKey(signer.publicKey.toUint8Array()),
        new Ed25519Signature(signerSignature.toUint8Array())
      );
    case 2:
      return new AccountAuthenticatorSingleKey(signer.publicKey, new AnySignature(signerSignature));
    default:
      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);
  }
}
function generateSignedTransaction(args) {
  const { transaction, senderAuthenticator, secondarySignerAuthenticators } = args;
  const transactionToSubmit = deriveTransactionType(transaction);
  if (secondarySignerAuthenticators) {
    return generateMultiSignersSignedTransaction(
      transactionToSubmit,
      senderAuthenticator,
      secondarySignerAuthenticators
    );
  }
  if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {
    const transactionAuthenticator = new TransactionAuthenticatorEd25519(
      senderAuthenticator.public_key,
      senderAuthenticator.signature
    );
    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();
  }
  if (senderAuthenticator instanceof AccountAuthenticatorSingleKey || senderAuthenticator instanceof AccountAuthenticatorMultiKey) {
    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);
    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();
  }
  throw new Error(
    `Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`
  );
}
function deriveTransactionType(transaction) {
  var _a;
  const deserializer = new Deserializer(transaction.rawTransaction);
  const deserializedTransaction = RawTransaction.deserialize(deserializer);
  if (transaction.feePayerAddress) {
    return new FeePayerRawTransaction(
      deserializedTransaction,
      (_a = transaction.secondarySignerAddresses) != null ? _a : [],
      transaction.feePayerAddress
    );
  }
  if (transaction.secondarySignerAddresses) {
    return new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);
  }
  return deserializedTransaction;
}
function generateMultiSignersSignedTransaction(transaction, senderAuthenticator, secondarySignerAuthenticators) {
  if (transaction instanceof FeePayerRawTransaction) {
    if (!secondarySignerAuthenticators.feePayerAuthenticator) {
      throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    }
    const { feePayerAuthenticator, additionalSignersAuthenticators } = secondarySignerAuthenticators;
    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(
      senderAuthenticator,
      transaction.secondary_signer_addresses,
      additionalSignersAuthenticators != null ? additionalSignersAuthenticators : [],
      {
        address: transaction.fee_payer_address,
        authenticator: feePayerAuthenticator
      }
    );
    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();
  }
  if (transaction instanceof MultiAgentRawTransaction) {
    if (!secondarySignerAuthenticators.additionalSignersAuthenticators) {
      throw new Error(
        "Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction"
      );
    }
    const { additionalSignersAuthenticators } = secondarySignerAuthenticators;
    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(
      senderAuthenticator,
      transaction.secondary_signer_addresses,
      additionalSignersAuthenticators != null ? additionalSignersAuthenticators : []
    );
    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();
  }
  throw new Error(
    `Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`
  );
}
function getSigningMessage(rawTxn) {
  const hash3 = sha3_256.create();
  if (rawTxn instanceof RawTransaction) {
    hash3.update(RAW_TRANSACTION_SALT);
  } else if (rawTxn instanceof MultiAgentRawTransaction) {
    hash3.update(RAW_TRANSACTION_WITH_DATA_SALT);
  } else if (rawTxn instanceof FeePayerRawTransaction) {
    hash3.update(RAW_TRANSACTION_WITH_DATA_SALT);
  } else {
    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);
  }
  const prefix = hash3.digest();
  const body = rawTxn.bcsToBytes();
  const mergedArray = new Uint8Array(prefix.length + body.length);
  mergedArray.set(prefix);
  mergedArray.set(body, prefix.length);
  return mergedArray;
}
async function generateTransaction(args) {
  const { aptosConfig, sender, data, options, secondarySignerAddresses, feePayerAddress } = args;
  let generateTransactionPayloadData;
  if ("bytecode" in data) {
    generateTransactionPayloadData = data;
  } else if ("multisigAddress" in data) {
    generateTransactionPayloadData = {
      aptosConfig,
      multisigAddress: data.multisigAddress,
      function: data.function,
      functionArguments: data.functionArguments,
      typeArguments: data.typeArguments
    };
  } else {
    generateTransactionPayloadData = {
      aptosConfig,
      function: data.function,
      functionArguments: data.functionArguments,
      typeArguments: data.typeArguments
    };
  }
  const payload = await generateTransactionPayload(generateTransactionPayloadData);
  return buildTransaction({
    aptosConfig,
    sender,
    payload,
    options,
    secondarySignerAddresses,
    feePayerAddress
  });
}
function signTransaction(args) {
  const accountAuthenticator = sign({ ...args });
  return accountAuthenticator;
}
async function simulateTransaction(args) {
  var _a, _b, _c, _d, _e, _f;
  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;
  const signedTransaction = generateSignedTransactionForSimulation({
    transaction,
    signerPublicKey,
    secondarySignersPublicKeys,
    feePayerPublicKey,
    options
  });
  const { data } = await postAptosFullNode({
    aptosConfig,
    body: signedTransaction,
    path: "transactions/simulate",
    params: {
      estimate_gas_unit_price: (_b = (_a = args.options) == null ? void 0 : _a.estimateGasUnitPrice) != null ? _b : false,
      estimate_max_gas_amount: (_d = (_c = args.options) == null ? void 0 : _c.estimateMaxGasAmount) != null ? _d : false,
      estimate_prioritized_gas_unit_price: (_f = (_e = args.options) == null ? void 0 : _e.estimatePrioritizedGasUnitPrice) != null ? _f : false
    },
    originMethod: "simulateTransaction",
    contentType: "application/x.aptos.signed_transaction+bcs"
    /* BCS_SIGNED_TRANSACTION */
  });
  return data;
}
async function submitTransaction(args) {
  const { aptosConfig } = args;
  const signedTransaction = generateSignedTransaction({ ...args });
  const { data } = await postAptosFullNode({
    aptosConfig,
    body: signedTransaction,
    path: "transactions",
    originMethod: "submitTransaction",
    contentType: "application/x.aptos.signed_transaction+bcs"
    /* BCS_SIGNED_TRANSACTION */
  });
  return data;
}
async function signAndSubmitTransaction(args) {
  const { aptosConfig, signer, transaction } = args;
  const authenticator = signTransaction({ signer, transaction });
  return submitTransaction({
    aptosConfig,
    transaction,
    senderAuthenticator: authenticator
  });
}
async function publicPackageTransaction(args) {
  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;
  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));
  const transaction = await generateTransaction({
    aptosConfig,
    sender: account,
    data: {
      function: "0x1::code::publish_package_txn",
      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)]
    },
    options
  });
  return transaction;
}
async function transferCoinTransaction(args) {
  const { aptosConfig, sender, recipient, amount, coinType, options } = args;
  const coinStructType = coinType != null ? coinType : APTOS_COIN;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: sender.accountAddress.toString(),
    data: {
      function: "0x1::aptos_account::transfer_coins",
      typeArguments: [parseTypeTag(coinStructType)],
      functionArguments: [AccountAddress.fromHexInput(recipient), new U64(amount)]
    },
    options
  });
  return transaction;
}
var Coin = class {
  constructor(config) {
    this.config = config;
  }
  async transferCoinTransaction(args) {
    return transferCoinTransaction({ aptosConfig: this.config, ...args });
  }
};
async function mintTokenTransaction(args) {
  const { aptosConfig, options, creator } = args;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: creator.accountAddress.toString(),
    data: {
      function: "0x4::aptos_token::mint",
      functionArguments: [
        new MoveString(args.collection),
        new MoveString(args.description),
        new MoveString(args.name),
        new MoveString(args.uri),
        MoveVector.MoveString([]),
        MoveVector.MoveString([]),
        new MoveVector([])
      ]
    },
    options
  });
  return transaction;
}
async function getTokenData(args) {
  const { aptosConfig, tokenAddress } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetTokenData,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getTokenData"
  });
  return data.current_token_datas_v2[0];
}
async function getCurrentTokenOwnership(args) {
  const { aptosConfig, tokenAddress } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetCurrentTokenOwnership,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCurrentTokenOwnership"
  });
  return data.current_token_ownerships_v2[0];
}
async function getOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, ownerAddress, options } = args;
  const whereCondition = {
    owner_address: { _eq: Hex.fromHexInput(ownerAddress).toString() }
  };
  const graphqlQuery = {
    query: GetCurrentTokenOwnership,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getOwnedTokens"
  });
  return data.current_token_ownerships_v2;
}
async function getTokenActivity(args) {
  var _a, _b;
  const { aptosConfig, tokenAddress, options } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetTokenActivity,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getTokenActivity"
  });
  return data.token_activities_v2;
}
async function createCollectionTransaction(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const { aptosConfig, options, creator } = args;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: creator.accountAddress.toString(),
    data: {
      function: "0x4::aptos_token::create_collection",
      functionArguments: [
        new MoveString(args.description),
        new U64((_a = args.maxSupply) != null ? _a : MAX_U64_BIG_INT),
        new MoveString(args.name),
        new MoveString(args.uri),
        new Bool((_b = args.mutableDescription) != null ? _b : true),
        new Bool((_c = args.mutableRoyalty) != null ? _c : true),
        new Bool((_d = args.mutableURI) != null ? _d : true),
        new Bool((_e = args.mutableTokenDescription) != null ? _e : true),
        new Bool((_f = args.mutableTokenName) != null ? _f : true),
        new Bool((_g = args.mutableTokenProperties) != null ? _g : true),
        new Bool((_h = args.mutableTokenURI) != null ? _h : true),
        new Bool((_i = args.tokensBurnableByCreator) != null ? _i : true),
        new Bool((_j = args.tokensFreezableByCreator) != null ? _j : true),
        new U64((_k = args.royaltyNumerator) != null ? _k : 0),
        new U64((_l = args.royaltyDenominator) != null ? _l : 1)
      ]
    },
    options
  });
  return transaction;
}
async function getCollectionData(args) {
  var _a;
  const { aptosConfig, creatorAddress, collectionName, options } = args;
  const address = Hex.fromHexInput(creatorAddress).toString();
  const whereCondition = {
    collection_name: { _eq: collectionName },
    creator_address: { _eq: address }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: (_a = options == null ? void 0 : options.tokenStandard) != null ? _a : "v2" };
  }
  const graphqlQuery = {
    query: GetCollectionData,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCollectionData"
  });
  return data.current_collections_v2[0];
}
async function getCollectionId(args) {
  return (await getCollectionData(args)).collection_id;
}
var DigitalAsset = class {
  constructor(config) {
    this.config = config;
  }
  async createCollectionTransaction(args) {
    return createCollectionTransaction({ aptosConfig: this.config, ...args });
  }
  async getCollectionData(args) {
    return getCollectionData({ aptosConfig: this.config, ...args });
  }
  async getCollectionId(args) {
    return getCollectionId({ aptosConfig: this.config, ...args });
  }
  async mintTokenTransaction(args) {
    return mintTokenTransaction({ aptosConfig: this.config, ...args });
  }
  async getTokenData(args) {
    return getTokenData({ aptosConfig: this.config, ...args });
  }
  async getCurrentTokenOwnership(args) {
    return getCurrentTokenOwnership({ aptosConfig: this.config, ...args });
  }
  async getOwnedTokens(args) {
    return getOwnedTokens({ aptosConfig: this.config, ...args });
  }
  async getTokenActivity(args) {
    return getTokenActivity({ aptosConfig: this.config, ...args });
  }
};
async function getAccountEventsByCreationNumber(args) {
  const { accountAddress, aptosConfig, creationNumber } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    account_address: { _eq: address },
    creation_number: { _eq: creationNumber }
  };
  return getEvents({ aptosConfig, options: { where: whereCondition } });
}
async function getAccountEventsByEventType(args) {
  const { accountAddress, aptosConfig, eventType, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    account_address: { _eq: address },
    type: { _eq: eventType }
  };
  const customOptions = {
    where: whereCondition,
    pagination: options == null ? void 0 : options.pagination,
    orderBy: options == null ? void 0 : options.orderBy
  };
  return getEvents({ aptosConfig, options: customOptions });
}
async function getEvents(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetEvents,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getEvents"
  });
  return data.events;
}
var Event = class {
  constructor(config) {
    this.config = config;
  }
  async getAccountEventsByCreationNumber(args) {
    return getAccountEventsByCreationNumber({ aptosConfig: this.config, ...args });
  }
  async getAccountEventsByEventType(args) {
    return getAccountEventsByEventType({ aptosConfig: this.config, ...args });
  }
  async getEvents(args) {
    return getEvents({ aptosConfig: this.config, ...args });
  }
};
async function fundAccount(args) {
  const { aptosConfig, accountAddress, amount, options } = args;
  const timeout = (options == null ? void 0 : options.timeoutSecs) || DEFAULT_TXN_TIMEOUT_SEC;
  const { data } = await postAptosFaucet({
    aptosConfig,
    path: "fund",
    body: {
      address: AccountAddress.fromHexInput(accountAddress).toString(),
      amount
    },
    originMethod: "fundAccount"
  });
  const txnHash = data.txn_hashes[0];
  await waitForTransaction({
    aptosConfig,
    transactionHash: txnHash,
    options: {
      timeoutSecs: timeout,
      checkSuccess: options == null ? void 0 : options.checkSuccess,
      indexerVersionCheck: options == null ? void 0 : options.indexerVersionCheck
    }
  });
  return txnHash;
}
var Faucet = class {
  constructor(config) {
    this.config = config;
  }
  async fundAccount(args) {
    return fundAccount({ aptosConfig: this.config, ...args });
  }
};
async function getFungibleAssetMetadata(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetFungibleAssetMetadata,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getFungibleAssetMetadata"
  });
  return data.fungible_asset_metadata;
}
async function getFungibleAssetActivities(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetFungibleAssetActivities,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getFungibleAssetActivities"
  });
  return data.fungible_asset_activities;
}
async function getCurrentFungibleAssetBalances(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetCurrentFungibleAssetBalances,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCurrentFungibleAssetBalances"
  });
  return data.current_fungible_asset_balances;
}
var FungibleAsset = class {
  constructor(config) {
    this.config = config;
  }
  async getFungibleAssetMetadata(args) {
    return getFungibleAssetMetadata({ aptosConfig: this.config, ...args });
  }
  async getFungibleAssetMetadataByAssetType(assetType) {
    const data = await getFungibleAssetMetadata({
      aptosConfig: this.config,
      options: {
        where: {
          asset_type: { _eq: assetType }
        }
      }
    });
    return data[0];
  }
  async getFungibleAssetActivities(args) {
    return getFungibleAssetActivities({ aptosConfig: this.config, ...args });
  }
  async getCurrentFungibleAssetBalances(args) {
    return getCurrentFungibleAssetBalances({ aptosConfig: this.config, ...args });
  }
};
var General = class {
  constructor(config) {
    this.config = config;
  }
  async getLedgerInfo() {
    return getLedgerInfo({ aptosConfig: this.config });
  }
  async getChainId() {
    const result = await this.getLedgerInfo();
    return result.chain_id;
  }
  async getBlockByVersion(args) {
    return getBlockByVersion({
      aptosConfig: this.config,
      ...args
    });
  }
  async getBlockByHeight(args) {
    return getBlockByHeight({ aptosConfig: this.config, ...args });
  }
  async getTableItem(args) {
    return getTableItem({ aptosConfig: this.config, ...args });
  }
  async view(args) {
    return view({ aptosConfig: this.config, ...args });
  }
  async getChainTopUserTransactions(args) {
    return getChainTopUserTransactions({
      aptosConfig: this.config,
      ...args
    });
  }
  async queryIndexer(args) {
    return queryIndexer({
      aptosConfig: this.config,
      ...args
    });
  }
  async getIndexerLastSuccessVersion() {
    return getIndexerLastSuccessVersion({ aptosConfig: this.config });
  }
};
async function getNumberOfDelegators(args) {
  const { aptosConfig, poolAddress } = args;
  const address = Hex.fromHexInput(poolAddress).toString();
  const query = {
    query: GetNumberOfDelegators,
    variables: { where_condition: { pool_address: { _eq: address } } }
  };
  const data = await queryIndexer({ aptosConfig, query });
  if (data.num_active_delegator_per_pool.length === 0) {
    throw Error("Delegator pool not found");
  }
  return data.num_active_delegator_per_pool[0].num_active_delegator;
}
async function getNumberOfDelegatorsForAllPools(args) {
  const { aptosConfig, options } = args;
  const query = {
    query: GetNumberOfDelegators,
    variables: { where_condition: {}, order_by: options == null ? void 0 : options.orderBy }
  };
  const data = await queryIndexer({
    aptosConfig,
    query
  });
  return data.num_active_delegator_per_pool;
}
async function getDelegatedStakingActivities(args) {
  const { aptosConfig, delegatorAddress, poolAddress } = args;
  const query = {
    query: GetDelegatedStakingActivities,
    variables: {
      delegatorAddress: Hex.fromHexInput(delegatorAddress).toString(),
      poolAddress: Hex.fromHexInput(poolAddress).toString()
    }
  };
  const data = await queryIndexer({ aptosConfig, query });
  return data.delegated_staking_activities;
}
var Staking = class {
  constructor(config) {
    this.config = config;
  }
  async getNumberOfDelegators(args) {
    return getNumberOfDelegators({ aptosConfig: this.config, ...args });
  }
  async getNumberOfDelegatorsForAllPools(args) {
    return getNumberOfDelegatorsForAllPools({ aptosConfig: this.config, ...args });
  }
  async getDelegatedStakingActivities(args) {
    return getDelegatedStakingActivities({ aptosConfig: this.config, ...args });
  }
};
var Transaction = class {
  constructor(config) {
    this.config = config;
  }
  async getTransactions(args) {
    return getTransactions2({
      aptosConfig: this.config,
      ...args
    });
  }
  async getTransactionByVersion(args) {
    return getTransactionByVersion({
      aptosConfig: this.config,
      ...args
    });
  }
  async getTransactionByHash(args) {
    return getTransactionByHash({
      aptosConfig: this.config,
      ...args
    });
  }
  async isPendingTransaction(args) {
    return isTransactionPending({
      aptosConfig: this.config,
      ...args
    });
  }
  async waitForTransaction(args) {
    return waitForTransaction({
      aptosConfig: this.config,
      ...args
    });
  }
  async getGasPriceEstimation() {
    return getGasPriceEstimation({
      aptosConfig: this.config
    });
  }
};
var TransactionSubmission = class {
  constructor(config) {
    this.config = config;
  }
  async generateTransaction(args) {
    return generateTransaction({ aptosConfig: this.config, ...args });
  }
  signTransaction(args) {
    return signTransaction({ ...args });
  }
  async simulateTransaction(args) {
    return simulateTransaction({ aptosConfig: this.config, ...args });
  }
  async submitTransaction(args) {
    return submitTransaction({ aptosConfig: this.config, ...args });
  }
  async signAndSubmitTransaction(args) {
    const { signer, transaction } = args;
    return signAndSubmitTransaction({
      aptosConfig: this.config,
      signer,
      transaction
    });
  }
  async publishPackageTransaction(args) {
    return publicPackageTransaction({ aptosConfig: this.config, ...args });
  }
};
var Aptos = class {
  constructor(settings) {
    this.config = new AptosConfig(settings);
    this.account = new Account2(this.config);
    this.coin = new Coin(this.config);
    this.digitalAsset = new DigitalAsset(this.config);
    this.event = new Event(this.config);
    this.faucet = new Faucet(this.config);
    this.fungibleAsset = new FungibleAsset(this.config);
    this.general = new General(this.config);
    this.staking = new Staking(this.config);
    this.transaction = new Transaction(this.config);
    this.transactionSubmission = new TransactionSubmission(this.config);
  }
};
function applyMixin(targetClass, baseClass, baseClassProp) {
  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {
    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);
    if (!propertyDescriptor)
      return;
    propertyDescriptor.value = function(...args) {
      return this[baseClassProp][propertyName](...args);
    };
    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);
  });
}
applyMixin(Aptos, Account2, "account");
applyMixin(Aptos, Coin, "coin");
applyMixin(Aptos, DigitalAsset, "digitalAsset");
applyMixin(Aptos, Event, "event");
applyMixin(Aptos, Faucet, "faucet");
applyMixin(Aptos, FungibleAsset, "fungibleAsset");
applyMixin(Aptos, General, "general");
applyMixin(Aptos, Staking, "staking");
applyMixin(Aptos, Transaction, "transaction");
applyMixin(Aptos, TransactionSubmission, "transactionSubmission");

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
var ChainIdToAnsContractAddressMap = {
  "1": "mainnet",
  "2": "testnet"
};
var getNameByAddress = async (chainId, address) => {
  try {
    if (!ChainIdToAnsContractAddressMap[chainId])
      return null;
    const response = await fetch(
      `https://www.aptosnames.com/api/${ChainIdToAnsContractAddressMap[chainId]}/v1/name/${address}`
    );
    const data = await response.json();
    return data.name;
  } catch (e) {
    console.log("error", e);
    return null;
  }
};
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name.toLowerCase()) {
    case "mainnet":
      return Network.MAINNET;
    case "testnet":
      return Network.TESTNET;
    case "devnet":
      return Network.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function convertToBCSPayload(payload) {
  const deserializer = new bcs_exports.Deserializer(payload.bcsToBytes());
  return aptos_types_exports.TransactionPayload.deserialize(deserializer);
}
var WalletCore = class extends import_eventemitter3.default {
  constructor(plugins) {
    super();
    this._wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this._connecting = false;
    this._connected = false;
    this._wallets = plugins;
    this.scopePollingDetectionStrategy();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" : "NotDetected";
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed";
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      const name = await getNameByAddress(
        this._network.chainId,
        this._account.address
      );
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    this._account = account;
  }
  setNetwork(network) {
    this._network = network;
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a;
    const selectedWallet = (_a = this._wallets) == null ? void 0 : _a.find(
      (wallet) => wallet.name === walletName
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (selectedWallet.name === walletName)
        throw new WalletConnectionError(
          `${walletName} wallet is already connected`
        ).message;
    }
    if (isRedirectable()) {
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
    }
    if (selectedWallet.readyState !== "Installed" && selectedWallet.readyState !== "Loadable") {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      const account = await selectedWallet.connect();
      this.setAccount({ ...account });
      const network = await selectedWallet.network();
      this.setNetwork({ ...network });
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.disconnect());
      this.clearData();
      this.emit("disconnect");
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transaction, options) {
    var _a;
    try {
      this.doesWalletExist();
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signAndSubmitTransaction(
        transaction,
        options
      ));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, options) {
    var _a;
    if (this._wallet && !("signAndSubmitBCSTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, options) {
    var _a;
    if (this._wallet && !("signTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._wallet)
        return null;
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transactionInput, options) {
    const payloadData = transactionInput.data;
    const aptosConfig = new AptosConfig({ network: convertNetwork(this._network) });
    const newPayload = await generateTransactionPayload({ ...payloadData, aptosConfig });
    const oldTransactionPayload = convertToBCSPayload(newPayload);
    const response = await this.signAndSubmitBCSTransaction(oldTransactionPayload, options);
    const { hash: hash3, ...output3 } = response;
    return { hash: hash3, output: output3 };
  }
  async signMultiAgentTransaction(transaction) {
    var _a;
    if (this._wallet && !("signMultiAgentTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Multi-agent & sponsored transactions are not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signMultiAgentTransaction(
        transaction
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onAccountChange(async (data) => {
        this.setAccount({ ...data });
        await this.setAnsName();
        this.emit("accountChange", this._account);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onNetworkChange(async (data) => {
        this.setNetwork({ ...data });
        await this.setAnsName();
        this.emit("networkChange", this._network);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._account)
        throw new Error("No account found!");
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = this._account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n) => Array.from({ length: 8 }).map((_, i) => n >> i & 1)
            );
            const index = bits.map((_, i) => i).filter((i) => bits[i]);
            const publicKeys = this._account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i) => index.includes(i)
            );
            verified = true;
            for (let i = 0; i < signature.length; i++) {
              const isSigVerified = import_tweetnacl2.default.sign.detached.verify(
                import_buffer.Buffer.from(fullMessage),
                import_buffer.Buffer.from(signature[i], "hex"),
                import_buffer.Buffer.from(matchedPublicKeys[i], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          this._account.publicKey
        );
        const signature = new HexString(response.signature);
        verified = import_tweetnacl2.default.sign.detached.verify(
          import_buffer.Buffer.from(response.fullMessage),
          import_buffer.Buffer.from(signature.noPrefix(), "hex"),
          import_buffer.Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var DEFAULT_COUNTEXT = {
  connected: false
};
var WalletContext = (0, import_react.createContext)(
  DEFAULT_COUNTEXT
);
function useWallet() {
  const context = (0, import_react.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  plugins,
  autoConnect = false,
  onError
}) => {
  const [{ connected, account, network, wallet }, setState] = (0, import_react2.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react2.useState)(true);
  const walletCore = (0, import_react2.useMemo)(() => new WalletCore(plugins), []);
  const [wallets, setWallets] = (0, import_react2.useState)(
    walletCore.wallets
  );
  const connect = async (walletName) => {
    try {
      setIsLoading(true);
      await walletCore.connect(walletName);
    } catch (error) {
      console.log("connect error", error);
      if (onError)
        onError(error);
      else
        throw error;
    } finally {
      setIsLoading(false);
    }
  };
  const disconnect = async () => {
    try {
      await walletCore.disconnect();
    } catch (e) {
      console.log("disconnect error", e);
      if (onError)
        onError(e);
    }
  };
  const signAndSubmitTransaction2 = async (transaction, options) => {
    try {
      return await walletCore.signAndSubmitTransaction(transaction, options);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  };
  const signAndSubmitBCSTransaction = async (transaction, options) => {
    try {
      return await walletCore.signAndSubmitBCSTransaction(transaction, options);
    } catch (error) {
      throw error;
    }
  };
  const signTransaction2 = async (transaction, options) => {
    try {
      return await walletCore.signTransaction(transaction, options);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  };
  const signMessage = async (message) => {
    try {
      return await walletCore.signMessage(message);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return null;
    }
  };
  const signMessageAndVerify = async (message) => {
    try {
      return await walletCore.signMessageAndVerify(message);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  const signMultiAgentTransaction = async (transaction) => {
    try {
      return await walletCore.signMultiAgentTransaction(transaction);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  const submitTransaction2 = async (transaction) => {
    try {
      return await walletCore.submitTransaction(transaction);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  (0, import_react2.useEffect)(() => {
    if (autoConnect) {
      if (localStorage.getItem("AptosWalletName")) {
        connect(localStorage.getItem("AptosWalletName"));
      } else {
        setIsLoading(false);
      }
    }
  }, wallets);
  (0, import_react2.useEffect)(() => {
    if (connected) {
      walletCore.onAccountChange();
      walletCore.onNetworkChange();
    }
  }, [...wallets, connected]);
  const handleConnect = () => {
    setState((state) => {
      return {
        ...state,
        connected: true,
        account: walletCore.account,
        network: walletCore.network,
        wallet: walletCore.wallet
      };
    });
  };
  const handleDisconnect = () => {
    if (!connected)
      return;
    setState((state) => {
      return {
        ...state,
        connected: false,
        account: walletCore.account,
        network: walletCore.network,
        wallet: null
      };
    });
  };
  const handleAccountChange = (0, import_react2.useCallback)(() => {
    if (!connected)
      return;
    if (!walletCore.wallet)
      return;
    setState((state) => {
      return {
        ...state,
        account: walletCore.account
      };
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react2.useCallback)(() => {
    if (!connected)
      return;
    if (!walletCore.wallet)
      return;
    setState((state) => {
      return {
        ...state,
        network: walletCore.network
      };
    });
  }, [connected]);
  const handleReadyStateChange = (wallet2) => {
    setWallets((wallets2) => [...wallets2]);
  };
  (0, import_react2.useEffect)(() => {
    walletCore.on("connect", handleConnect);
    walletCore.on("disconnect", handleDisconnect);
    walletCore.on("accountChange", handleAccountChange);
    walletCore.on("networkChange", handleNetworkChange);
    walletCore.on("readyStateChange", handleReadyStateChange);
    return () => {
      walletCore.off("connect", handleConnect);
      walletCore.off("disconnect", handleDisconnect);
      walletCore.off("accountChange", handleAccountChange);
      walletCore.off("networkChange", handleNetworkChange);
      walletCore.off("readyStateChange", handleReadyStateChange);
    };
  }, [...wallets, connected]);
  return (0, import_jsx_runtime.jsx)(WalletContext.Provider, {
    value: {
      connect,
      account,
      network,
      connected,
      disconnect,
      wallet,
      wallets,
      signAndSubmitTransaction: signAndSubmitTransaction2,
      signAndSubmitBCSTransaction,
      signTransaction: signTransaction2,
      signMessage,
      signMessageAndVerify,
      signMultiAgentTransaction,
      submitTransaction: submitTransaction2,
      isLoading
    },
    children
  });
};

export {
  WalletReadyState,
  NetworkName,
  isMobile,
  isInAppBrowser,
  isRedirectable,
  useWallet,
  AptosWalletAdapterProvider
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-E5EHAF5Z.js.map
